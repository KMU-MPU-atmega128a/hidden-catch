NOTE: Code bytes are displayed in order matching the disassembly format in AVR documentation.
  For example, 'CALL 2B16' (example only, only labels should normally be used) is displayed as
  0x940E2B16 rather than in little endian byte order.

Interrupt Vectors

Program Code (text area)
_CGRAM_set_menu:
  i                    --> R20
  i                    --> R20
  i                    --> R20
  i                    --> R20
  i                    --> R20
  i                    --> R20
  menu6                --> Y,+40
  menu5                --> Y,+32
  menu4                --> Y,+24
  menu3                --> Y,+16
  menu2                --> Y,+8
  menu1                --> Y,+0
    000D9 934A      ST	-Y,R20
    000DA 935A      ST	-Y,R21
    000DB 97E0      SBIW	R28,0x30
FILE: C:\Users\user\Desktop\hidden-catch\cgram.c
(0001) #include "cgram.h"
(0002) 
(0003) void CGRAM_set_menu(void) { // 초기 화면 함수 ("다른문자찾기" 출력)
(0004)     Byte menu1[] = {0x02, 0x1E, 0x12, 0x13, 0x12, 0x1E, 0x02, 0x02};
    000DC ED84      LDI	R24,0xD4
    000DD E090      LDI	R25,0
    000DE 01FE      MOVW	R30,R28
    000DF E008      LDI	R16,0x8
    000E0 E010      LDI	R17,0
    000E1 93FA      ST	-Y,R31
    000E2 93EA      ST	-Y,R30
    000E3 939A      ST	-Y,R25
    000E4 938A      ST	-Y,R24
    000E5 940E 05B0 CALL	asgncblkx
(0005)     Byte menu2[] = {0x0E, 0x02, 0x0E, 0x08, 0x0E, 0x1F, 0x08, 0x0E};
    000E7 ED8C      LDI	R24,0xDC
    000E8 E090      LDI	R25,0
    000E9 01FE      MOVW	R30,R28
    000EA 9638      ADIW	R30,0x8
    000EB E008      LDI	R16,0x8
    000EC E010      LDI	R17,0
    000ED 93FA      ST	-Y,R31
    000EE 93EA      ST	-Y,R30
    000EF 939A      ST	-Y,R25
    000F0 938A      ST	-Y,R24
    000F1 940E 05B0 CALL	asgncblkx
(0006)     Byte menu3[] = {0x0E, 0x0A, 0x0E, 0x00, 0x1F, 0x04, 0x08, 0x0E};
    000F3 EE84      LDI	R24,0xE4
    000F4 E090      LDI	R25,0
    000F5 01FE      MOVW	R30,R28
    000F6 9670      ADIW	R30,0x10
    000F7 E008      LDI	R16,0x8
    000F8 E010      LDI	R17,0
    000F9 93FA      ST	-Y,R31
    000FA 93EA      ST	-Y,R30
    000FB 939A      ST	-Y,R25
    000FC 938A      ST	-Y,R24
    000FD 940E 05B0 CALL	asgncblkx
(0007)     Byte menu4[] = {0x02, 0x1E, 0x0A, 0x17, 0x16, 0x02, 0x02, 0x00};
    000FF EE8C      LDI	R24,0xEC
    00100 E090      LDI	R25,0
    00101 01FE      MOVW	R30,R28
    00102 9678      ADIW	R30,0x18
    00103 E008      LDI	R16,0x8
    00104 E010      LDI	R17,0
    00105 93FA      ST	-Y,R31
    00106 93EA      ST	-Y,R30
    00107 939A      ST	-Y,R25
    00108 938A      ST	-Y,R24
    00109 940E 05B0 CALL	asgncblkx
(0008)     Byte menu5[] = {0x0A, 0x1E, 0x0B, 0x16, 0x02, 0x0E, 0x04, 0x0A};
    0010B EF84      LDI	R24,0xF4
    0010C E090      LDI	R25,0
    0010D 01FE      MOVW	R30,R28
    0010E 96B0      ADIW	R30,0x20
    0010F E008      LDI	R16,0x8
    00110 E010      LDI	R17,0
    00111 93FA      ST	-Y,R31
    00112 93EA      ST	-Y,R30
    00113 939A      ST	-Y,R25
    00114 938A      ST	-Y,R24
    00115 940E 05B0 CALL	asgncblkx
(0009)     Byte menu6[] = {0x02, 0x1A, 0x0A, 0x0A, 0x0A, 0x0A, 0x02, 0x02};
    00117 EF8C      LDI	R24,0xFC
    00118 E090      LDI	R25,0
    00119 01FE      MOVW	R30,R28
    0011A 96B8      ADIW	R30,0x28
    0011B E008      LDI	R16,0x8
    0011C E010      LDI	R17,0
    0011D 93FA      ST	-Y,R31
    0011E 93EA      ST	-Y,R30
    0011F 939A      ST	-Y,R25
    00120 938A      ST	-Y,R24
    00121 940E 05B0 CALL	asgncblkx
(0010) 
(0011)     LCD_Comm(0x40); // CGRAM 주소: 0b01 000000
    00123 E400      LDI	R16,0x40
    00124 940E 0276 CALL	_LCD_Comm
(0012)     LCD_delay(1);
    00126 E001      LDI	R16,1
    00127 940E 0247 CALL	_LCD_delay
(0013)     for (int i = 0; i < 8; i++) {
    00129 2744      CLR	R20
    0012A 2755      CLR	R21
    0012B C00C      RJMP	0x0138
(0014)         LCD_Data(menu1[i]);
    0012C 01CE      MOVW	R24,R28
    0012D 01FA      MOVW	R30,R20
    0012E 0FE8      ADD	R30,R24
    0012F 1FF9      ADC	R31,R25
    00130 8100      LD	R16,Z
    00131 940E 0255 CALL	_LCD_Data
(0015)         LCD_delay(1);
    00133 E001      LDI	R16,1
    00134 940E 0247 CALL	_LCD_delay
    00136 5F4F      SUBI	R20,0xFF
    00137 4F5F      SBCI	R21,0xFF
    00138 E088      LDI	R24,0x8
    00139 E090      LDI	R25,0
    0013A 1748      CP	R20,R24
    0013B 0759      CPC	R21,R25
    0013C F37C      BLT	0x012C
(0016)     }
(0017) 
(0018)     LCD_Comm(0x48); // CGRAM 주소: 0b01 001000
    0013D E408      LDI	R16,0x48
    0013E 940E 0276 CALL	_LCD_Comm
(0019)     LCD_delay(1);
    00140 E001      LDI	R16,1
    00141 940E 0247 CALL	_LCD_delay
(0020)     for (int i = 0; i < 8; i++) {
    00143 2744      CLR	R20
    00144 2755      CLR	R21
    00145 C00D      RJMP	0x0153
(0021)         LCD_Data(menu2[i]);
    00146 01CE      MOVW	R24,R28
    00147 9608      ADIW	R24,0x8
    00148 01FA      MOVW	R30,R20
    00149 0FE8      ADD	R30,R24
    0014A 1FF9      ADC	R31,R25
    0014B 8100      LD	R16,Z
    0014C 940E 0255 CALL	_LCD_Data
(0022)         LCD_delay(1);
    0014E E001      LDI	R16,1
    0014F 940E 0247 CALL	_LCD_delay
    00151 5F4F      SUBI	R20,0xFF
    00152 4F5F      SBCI	R21,0xFF
    00153 E088      LDI	R24,0x8
    00154 E090      LDI	R25,0
    00155 1748      CP	R20,R24
    00156 0759      CPC	R21,R25
    00157 F374      BLT	0x0146
(0023)     }
(0024) 
(0025)     LCD_Comm(0x50); // CGRAM 주소: 0b01 010000
    00158 E500      LDI	R16,0x50
    00159 940E 0276 CALL	_LCD_Comm
(0026)     LCD_delay(1);
    0015B E001      LDI	R16,1
    0015C 940E 0247 CALL	_LCD_delay
(0027)     for (int i = 0; i < 8; i++) {
    0015E 2744      CLR	R20
    0015F 2755      CLR	R21
    00160 C00D      RJMP	0x016E
(0028)         LCD_Data(menu3[i]);
    00161 01CE      MOVW	R24,R28
    00162 9640      ADIW	R24,0x10
    00163 01FA      MOVW	R30,R20
    00164 0FE8      ADD	R30,R24
    00165 1FF9      ADC	R31,R25
    00166 8100      LD	R16,Z
    00167 940E 0255 CALL	_LCD_Data
(0029)         LCD_delay(1);
    00169 E001      LDI	R16,1
    0016A 940E 0247 CALL	_LCD_delay
    0016C 5F4F      SUBI	R20,0xFF
    0016D 4F5F      SBCI	R21,0xFF
    0016E E088      LDI	R24,0x8
    0016F E090      LDI	R25,0
    00170 1748      CP	R20,R24
    00171 0759      CPC	R21,R25
    00172 F374      BLT	0x0161
(0030)     }
(0031) 
(0032)     LCD_Comm(0x58); // CGRAM 주소: 0b01 011000
    00173 E508      LDI	R16,0x58
    00174 940E 0276 CALL	_LCD_Comm
(0033)     LCD_delay(1);
    00176 E001      LDI	R16,1
    00177 940E 0247 CALL	_LCD_delay
(0034)     for (int i = 0; i < 8; i++) {
    00179 2744      CLR	R20
    0017A 2755      CLR	R21
    0017B C00D      RJMP	0x0189
(0035)         LCD_Data(menu4[i]);
    0017C 01CE      MOVW	R24,R28
    0017D 9648      ADIW	R24,0x18
    0017E 01FA      MOVW	R30,R20
    0017F 0FE8      ADD	R30,R24
    00180 1FF9      ADC	R31,R25
    00181 8100      LD	R16,Z
    00182 940E 0255 CALL	_LCD_Data
(0036)         LCD_delay(1);
    00184 E001      LDI	R16,1
    00185 940E 0247 CALL	_LCD_delay
    00187 5F4F      SUBI	R20,0xFF
    00188 4F5F      SBCI	R21,0xFF
    00189 E088      LDI	R24,0x8
    0018A E090      LDI	R25,0
    0018B 1748      CP	R20,R24
    0018C 0759      CPC	R21,R25
    0018D F374      BLT	0x017C
(0037)     }
(0038) 
(0039)     LCD_Comm(0x60); // CGRAM 주소: 0b01 100000
    0018E E600      LDI	R16,0x60
    0018F 940E 0276 CALL	_LCD_Comm
(0040)     LCD_delay(1);
    00191 E001      LDI	R16,1
    00192 940E 0247 CALL	_LCD_delay
(0041)     for (int i = 0; i < 8; i++) {
    00194 2744      CLR	R20
    00195 2755      CLR	R21
    00196 C00D      RJMP	0x01A4
(0042)         LCD_Data(menu5[i]);
    00197 01CE      MOVW	R24,R28
    00198 9680      ADIW	R24,0x20
    00199 01FA      MOVW	R30,R20
    0019A 0FE8      ADD	R30,R24
    0019B 1FF9      ADC	R31,R25
    0019C 8100      LD	R16,Z
    0019D 940E 0255 CALL	_LCD_Data
(0043)         LCD_delay(1);
    0019F E001      LDI	R16,1
    001A0 940E 0247 CALL	_LCD_delay
    001A2 5F4F      SUBI	R20,0xFF
    001A3 4F5F      SBCI	R21,0xFF
    001A4 E088      LDI	R24,0x8
    001A5 E090      LDI	R25,0
    001A6 1748      CP	R20,R24
    001A7 0759      CPC	R21,R25
    001A8 F374      BLT	0x0197
(0044)     }
(0045) 
(0046)     LCD_Comm(0x68); // CGRAM 주소: 0b01 101000
    001A9 E608      LDI	R16,0x68
    001AA 940E 0276 CALL	_LCD_Comm
(0047)     LCD_delay(1);
    001AC E001      LDI	R16,1
    001AD 940E 0247 CALL	_LCD_delay
(0048)     for (int i = 0; i < 8; i++) {
    001AF 2744      CLR	R20
    001B0 2755      CLR	R21
    001B1 C00D      RJMP	0x01BF
(0049)         LCD_Data(menu6[i]);
    001B2 01CE      MOVW	R24,R28
    001B3 9688      ADIW	R24,0x28
    001B4 01FA      MOVW	R30,R20
    001B5 0FE8      ADD	R30,R24
    001B6 1FF9      ADC	R31,R25
    001B7 8100      LD	R16,Z
    001B8 940E 0255 CALL	_LCD_Data
(0050)         LCD_delay(1);
    001BA E001      LDI	R16,1
    001BB 940E 0247 CALL	_LCD_delay
    001BD 5F4F      SUBI	R20,0xFF
    001BE 4F5F      SBCI	R21,0xFF
    001BF E088      LDI	R24,0x8
    001C0 E090      LDI	R25,0
    001C1 1748      CP	R20,R24
    001C2 0759      CPC	R21,R25
    001C3 F374      BLT	0x01B2
    001C4 96E0      ADIW	R28,0x30
    001C5 9159      LD	R21,Y+
    001C6 9149      LD	R20,Y+
    001C7 9508      RET
(0051)     }
(0052) }
_LCD_menu:
  i                    --> R20
    001C8 934A      ST	-Y,R20
(0053) 
(0054) void LCD_menu(void) {   // 초기 문자 "다른문자찾기" LCD에 출력
(0055)     for (Byte i = 0x00; i < 0x06; i++) {
    001C9 2744      CLR	R20
    001CA C007      RJMP	0x01D2
(0056)         LCD_Data(i);
    001CB 2F04      MOV	R16,R20
    001CC 940E 0255 CALL	_LCD_Data
(0057)         LCD_delay(1);
    001CE E001      LDI	R16,1
    001CF 940E 0247 CALL	_LCD_delay
    001D1 9543      INC	R20
    001D2 3046      CPI	R20,6
    001D3 F3B8      BCS	0x01CB
    001D4 9149      LD	R20,Y+
    001D5 9508      RET
(0058)     }
(0059) }
_CGRAM_set_quiz2:
  i                    --> R20
  i                    --> R20
  i                    --> R20
  q2_3                 --> Y,+16
  q2_2                 --> Y,+8
  q2_1                 --> Y,+0
    001D6 934A      ST	-Y,R20
    001D7 935A      ST	-Y,R21
    001D8 9768      SBIW	R28,0x18
(0060) 
(0061) void CGRAM_set_quiz2(void) {
(0062)     Byte q2_1[] = {0x09, 0x09, 0x09, 0x15, 0x01, 0x0E, 0x02, 0x02}; // '식'
    001D9 E084      LDI	R24,4
    001DA E091      LDI	R25,1
    001DB 01FE      MOVW	R30,R28
    001DC E008      LDI	R16,0x8
    001DD E010      LDI	R17,0
    001DE 93FA      ST	-Y,R31
    001DF 93EA      ST	-Y,R30
    001E0 939A      ST	-Y,R25
    001E1 938A      ST	-Y,R24
    001E2 940E 05B0 CALL	asgncblkx
(0063)     Byte q2_2[] = {0x02, 0x0A, 0x0A, 0x0B, 0x16, 0x02, 0x02, 0x02}; // '사'
    001E4 E08C      LDI	R24,0xC
    001E5 E091      LDI	R25,1
    001E6 01FE      MOVW	R30,R28
    001E7 9638      ADIW	R30,0x8
    001E8 E008      LDI	R16,0x8
    001E9 E010      LDI	R17,0
    001EA 93FA      ST	-Y,R31
    001EB 93EA      ST	-Y,R30
    001EC 939A      ST	-Y,R25
    001ED 938A      ST	-Y,R24
    001EE 940E 05B0 CALL	asgncblkx
(0064)     Byte q2_3[] = {0x02, 0x0A, 0x0B, 0x16, 0x17, 0x02, 0x02, 0x02}; // '샤'
    001F0 E184      LDI	R24,0x14
    001F1 E091      LDI	R25,1
    001F2 01FE      MOVW	R30,R28
    001F3 9670      ADIW	R30,0x10
    001F4 E008      LDI	R16,0x8
    001F5 E010      LDI	R17,0
    001F6 93FA      ST	-Y,R31
    001F7 93EA      ST	-Y,R30
    001F8 939A      ST	-Y,R25
    001F9 938A      ST	-Y,R24
    001FA 940E 05B0 CALL	asgncblkx
(0065) 
(0066)     LCD_Comm(0x40);     // CGRAM 주소: 0b01 000000
    001FC E400      LDI	R16,0x40
    001FD 940E 0276 CALL	_LCD_Comm
(0067)     for (int i = 0; i < 8; i++) {
    001FF 2744      CLR	R20
    00200 2755      CLR	R21
    00201 C00C      RJMP	0x020E
(0068)         LCD_Data(q2_1[i]);
    00202 01CE      MOVW	R24,R28
    00203 01FA      MOVW	R30,R20
    00204 0FE8      ADD	R30,R24
    00205 1FF9      ADC	R31,R25
    00206 8100      LD	R16,Z
    00207 940E 0255 CALL	_LCD_Data
(0069)         LCD_delay(1);
    00209 E001      LDI	R16,1
    0020A 940E 0247 CALL	_LCD_delay
    0020C 5F4F      SUBI	R20,0xFF
    0020D 4F5F      SBCI	R21,0xFF
    0020E E088      LDI	R24,0x8
    0020F E090      LDI	R25,0
    00210 1748      CP	R20,R24
    00211 0759      CPC	R21,R25
    00212 F37C      BLT	0x0202
(0070)     }
(0071) 
(0072)     LCD_Comm(0x48);     // CGRAM 주소: 0b01 001000
    00213 E408      LDI	R16,0x48
    00214 940E 0276 CALL	_LCD_Comm
(0073)     for (int i = 0; i < 8; i++) {
    00216 2744      CLR	R20
    00217 2755      CLR	R21
    00218 C00D      RJMP	0x0226
(0074)         LCD_Data(q2_2[i]);
    00219 01CE      MOVW	R24,R28
    0021A 9608      ADIW	R24,0x8
    0021B 01FA      MOVW	R30,R20
    0021C 0FE8      ADD	R30,R24
    0021D 1FF9      ADC	R31,R25
    0021E 8100      LD	R16,Z
    0021F 940E 0255 CALL	_LCD_Data
(0075)         LCD_delay(1);
    00221 E001      LDI	R16,1
    00222 940E 0247 CALL	_LCD_delay
    00224 5F4F      SUBI	R20,0xFF
    00225 4F5F      SBCI	R21,0xFF
    00226 E088      LDI	R24,0x8
    00227 E090      LDI	R25,0
    00228 1748      CP	R20,R24
    00229 0759      CPC	R21,R25
    0022A F374      BLT	0x0219
(0076)     }
(0077) 
(0078)     LCD_Comm(0x50);     // CGRAM 주소: 0b01 010000
    0022B E500      LDI	R16,0x50
    0022C 940E 0276 CALL	_LCD_Comm
(0079)     for (int i = 0; i < 8; i++) {
    0022E 2744      CLR	R20
    0022F 2755      CLR	R21
    00230 C00D      RJMP	0x023E
(0080)         LCD_Data(q2_3[i]);
    00231 01CE      MOVW	R24,R28
    00232 9640      ADIW	R24,0x10
    00233 01FA      MOVW	R30,R20
    00234 0FE8      ADD	R30,R24
    00235 1FF9      ADC	R31,R25
    00236 8100      LD	R16,Z
    00237 940E 0255 CALL	_LCD_Data
(0081)         LCD_delay(1);
    00239 E001      LDI	R16,1
    0023A 940E 0247 CALL	_LCD_delay
    0023C 5F4F      SUBI	R20,0xFF
    0023D 4F5F      SBCI	R21,0xFF
    0023E E088      LDI	R24,0x8
    0023F E090      LDI	R25,0
    00240 1748      CP	R20,R24
    00241 0759      CPC	R21,R25
    00242 F374      BLT	0x0231
    00243 9668      ADIW	R28,0x18
    00244 9159      LD	R21,Y+
    00245 9149      LD	R20,Y+
    00246 9508      RET
(0082)     }
(0083) }
(0084) /* 3번 CGRAM data (생각중...)
(0085) void CGRAM_set_quiz3(void) {
(0086)     Byte q3_1[] = {}
(0087)     Byte q3_2[];
(0088)     Byte q3_3[];
(0089)     Byte q3_4[];
(0090) 
(0091)     LCD_Comm(0x40);
(0092)     for (int i = 0; i < 8; i++) {
(0093)         LCD_Data(q3_1[i]);
(0094)         LCD_delay(1);
(0095)     }
(0096) 
(0097)     LCD_Comm(0x48);
(0098)     for (int i = 0; i < 8; i++) {
(0099)         LCD_Data(q3_2[i]);
(0100)         LCD_delay(1);
(0101)     }
(0102) 
(0103)     LCD_Comm(0x50);
(0104)     for (int i = 0; i < 8; i++) {
(0105)         LCD_Data(q3_3[i]);
(0106)         LCD_delay(1);
(0107)     }
(0108) 
(0109)     LCD_Comm(0x58);
(0110)     for (int i = 0; i < 8; i++) {
(0111)         LCD_Data(q3_4[i]);
(0112)         LCD_delay(1);
(0113)     }
(0114) 
(0115) }*/
    00248 2EA0      MOV	R10,R16
FILE: C:\Users\user\Desktop\hidden-catch\lcd.c
(0001) #include "lcd.h"
(0002) 
(0003) void LCD_delay(Byte ms) { delay_ms(ms); }   // LCD time delay
    00249 2D0A      MOV	R16,R10
    0024A 2711      CLR	R17
    0024B 940E 0433 CALL	_delay_ms
    0024D 90A9      LD	R10,Y+
    0024E 9508      RET
(0004) 
(0005) void PortInit(void) {
(0006)     DDRA = 0xFF;    // PORTA to output mode
_PortInit:
    0024F EF8F      LDI	R24,0xFF
    00250 BB8A      OUT	0x1A,R24
(0007)     DDRG = 0x0F;    // PORTG 0~3 to output mode
    00251 E08F      LDI	R24,0xF
    00252 9380 0064 STS	0x64,R24
    00254 9508      RET
(0008) }
_LCD_Data:
  ch                   --> R10
    00255 92AA      ST	-Y,R10
    00256 2EA0      MOV	R10,R16
(0009) 
(0010) void LCD_Data(Byte ch) {
(0011)     LCD_CTRL |=  (1 << LCD_RS); // RS  = 1
    00257 9180 0065 LDS	R24,0x65
    00259 6084      ORI	R24,4
    0025A 9380 0065 STS	0x65,R24
(0012)     LCD_CTRL &= ~(1 << LCD_RW); // R/W = 0 -> Enter data write cycle
    0025C 9180 0065 LDS	R24,0x65
    0025E 7F8D      ANDI	R24,0xFD
    0025F 9380 0065 STS	0x65,R24
(0013)     LCD_CTRL |=  (1 << LCD_EN); // enable LCD
    00261 9180 0065 LDS	R24,0x65
    00263 6081      ORI	R24,1
    00264 9380 0065 STS	0x65,R24
(0014)     delay_us(50);
    00266 E302      LDI	R16,0x32
    00267 E010      LDI	R17,0
    00268 940E 044A CALL	_delay_us
(0015) 
(0016)     LCD_WDATA = ch;             // Write DATA
    0026A BAAB      OUT	0x1B,R10
(0017)     delay_us(50);
    0026B E302      LDI	R16,0x32
    0026C E010      LDI	R17,0
    0026D 940E 044A CALL	_delay_us
(0018) 
(0019)     LCD_CTRL &= ~(1 << LCD_EN); // disable LCD
    0026F 9180 0065 LDS	R24,0x65
    00271 7F8E      ANDI	R24,0xFE
    00272 9380 0065 STS	0x65,R24
    00274 90A9      LD	R10,Y+
    00275 9508      RET
(0020) }   // Write Data to LCD Data Register (CGRAM, DDRAM)
_LCD_Comm:
  ch                   --> R10
    00276 92AA      ST	-Y,R10
    00277 2EA0      MOV	R10,R16
(0021) 
(0022) void LCD_Comm(Byte ch) {
(0023)     LCD_CTRL &= ~(1 << LCD_RS); // RS  = 0
    00278 9180 0065 LDS	R24,0x65
    0027A 7F8B      ANDI	R24,0xFB
    0027B 9380 0065 STS	0x65,R24
(0024)     LCD_CTRL &= ~(1 << LCD_RW); // R/W = 0 -> Enter instruction write cycle
    0027D 9180 0065 LDS	R24,0x65
    0027F 7F8D      ANDI	R24,0xFD
    00280 9380 0065 STS	0x65,R24
(0025)     LCD_CTRL |=  (1 << LCD_EN); // enable LCD
    00282 9180 0065 LDS	R24,0x65
    00284 6081      ORI	R24,1
    00285 9380 0065 STS	0x65,R24
(0026)     delay_us(50);
    00287 E302      LDI	R16,0x32
    00288 E010      LDI	R17,0
    00289 940E 044A CALL	_delay_us
(0027) 
(0028)     LCD_WINST = ch;             // Write INSTruction
    0028B BAAB      OUT	0x1B,R10
(0029)     delay_us(50);
    0028C E302      LDI	R16,0x32
    0028D E010      LDI	R17,0
    0028E 940E 044A CALL	_delay_us
(0030) 
(0031)     LCD_CTRL &= ~(1 << LCD_EN); // disable LCD
    00290 9180 0065 LDS	R24,0x65
    00292 7F8E      ANDI	R24,0xFE
    00293 9380 0065 STS	0x65,R24
    00295 90A9      LD	R10,Y+
    00296 9508      RET
(0032) }   // Write Instruction to LCD Instruction Register (CGRAM, DDRAM)
_LCD_Shift:
  p                    --> R20
    00297 934A      ST	-Y,R20
    00298 2F40      MOV	R20,R16
(0033) 
(0034) void LCD_Shift(char p) { // *
(0035)     if (p == RIGHT) {
    00299 3041      CPI	R20,1
    0029A F429      BNE	0x02A0
(0036)         LCD_Comm(0x1C);         // command: 0b00011100
    0029B E10C      LDI	R16,0x1C
    0029C DFD9      RCALL	_LCD_Comm
(0037)         LCD_delay(1);
    0029D E001      LDI	R16,1
    0029E DFA8      RCALL	_LCD_delay
(0038)     }
    0029F C006      RJMP	0x02A6
(0039)     else if (p == LEFT) {
    002A0 2344      TST	R20
    002A1 F421      BNE	0x02A6
(0040)         LCD_Comm(0x18);         // command: 0b00011000
    002A2 E108      LDI	R16,0x18
    002A3 DFD2      RCALL	_LCD_Comm
(0041)         LCD_delay(1);
    002A4 E001      LDI	R16,1
    002A5 DFA1      RCALL	_LCD_delay
    002A6 9149      LD	R20,Y+
    002A7 9508      RET
(0042)     }
(0043) }
_LCD_CHAR:
  c                    --> R10
    002A8 92AA      ST	-Y,R10
    002A9 2EA0      MOV	R10,R16
(0044) 
(0045) void LCD_CHAR(Byte c) {
(0046)     LCD_delay(1);
    002AA E001      LDI	R16,1
    002AB DF9B      RCALL	_LCD_delay
(0047)     LCD_Data(c);    // write char data C
    002AC 2D0A      MOV	R16,R10
    002AD DFA7      RCALL	_LCD_Data
    002AE 90A9      LD	R10,Y+
    002AF 9508      RET
(0048) }
_LCD_STR:
  str                  --> R20
    002B0 934A      ST	-Y,R20
    002B1 935A      ST	-Y,R21
    002B2 01A8      MOVW	R20,R16
(0049) 
(0050) void LCD_STR(Byte *str) {
    002B3 C005      RJMP	0x02B9
(0051)     while (*str != 0) {
(0052)         LCD_CHAR(*str); // write string data 'str'
    002B4 01FA      MOVW	R30,R20
    002B5 8100      LD	R16,Z
    002B6 DFF1      RCALL	_LCD_CHAR
(0053)         str++;
    002B7 5F4F      SUBI	R20,0xFF
    002B8 4F5F      SBCI	R21,0xFF
    002B9 01FA      MOVW	R30,R20
    002BA 8020      LD	R2,Z
    002BB 2022      TST	R2
    002BC F7B9      BNE	0x02B4
    002BD 9159      LD	R21,Y+
    002BE 9149      LD	R20,Y+
    002BF 9508      RET
(0054)     }
(0055) }
_LCD_pos:
  col                  --> R10
  row                  --> R12
    002C0 92AA      ST	-Y,R10
    002C1 92CA      ST	-Y,R12
    002C2 2EA2      MOV	R10,R18
    002C3 2EC0      MOV	R12,R16
(0056) 
(0057) void LCD_pos(unsigned char row, unsigned char col) {
(0058)     LCD_Comm(0x80 | (row * 0x40 + col));
    002C4 2D2C      MOV	R18,R12
    002C5 2733      CLR	R19
    002C6 E400      LDI	R16,0x40
    002C7 E010      LDI	R17,0
    002C8 940E 0577 CALL	empy16s
    002CA 0D0A      ADD	R16,R10
    002CB 6800      ORI	R16,0x80
    002CC DFA9      RCALL	_LCD_Comm
    002CD 90C9      LD	R12,Y+
    002CE 90A9      LD	R10,Y+
    002CF 9508      RET
(0059) }
(0060) 
(0061) void LCD_Clear(void) {
(0062)     LCD_Comm(0x01);
_LCD_Clear:
    002D0 E001      LDI	R16,1
    002D1 DFA4      RCALL	_LCD_Comm
(0063)     LCD_delay(2);
    002D2 E002      LDI	R16,2
    002D3 CF73      RJMP	_LCD_delay
(0064) }
(0065) 
(0066) void LCD_Init(void) {
(0067)     LCD_Comm(0x38); // DDRAM, 8 bit data 사용, lCD 2열로 사용
_LCD_Init:
    002D4 E308      LDI	R16,0x38
    002D5 DFA0      RCALL	_LCD_Comm
(0068)     LCD_delay(2);   // 2ms delay
    002D6 E002      LDI	R16,2
    002D7 DF6F      RCALL	_LCD_delay
(0069)     LCD_Comm(0x38);
    002D8 E308      LDI	R16,0x38
    002D9 DF9C      RCALL	_LCD_Comm
(0070)     LCD_delay(2);
    002DA E002      LDI	R16,2
    002DB DF6B      RCALL	_LCD_delay
(0071)     LCD_Comm(0x38);
    002DC E308      LDI	R16,0x38
    002DD DF98      RCALL	_LCD_Comm
(0072)     LCD_delay(2);
    002DE E002      LDI	R16,2
    002DF DF67      RCALL	_LCD_delay
(0073)     // 중요 초기 설정이라 3회 반복
(0074)     LCD_Comm(0x0C); // LCD 화면 ON, 커서 off, 문자 점멸 off (커서 on: 0x0E)
    002E0 E00C      LDI	R16,0xC
    002E1 DF94      RCALL	_LCD_Comm
(0075)     LCD_delay(2);
    002E2 E002      LDI	R16,2
    002E3 DF63      RCALL	_LCD_delay
(0076)     LCD_Comm(0x01); // Clear Display
    002E4 E001      LDI	R16,1
    002E5 DF90      RCALL	_LCD_Comm
(0077)     LCD_delay(30);
    002E6 E10E      LDI	R16,0x1E
    002E7 DF5F      RCALL	_LCD_delay
(0078)     LCD_Comm(0x06); // entry mode set (l->R 커서 이동, 화면 shift 없음)
    002E8 E006      LDI	R16,6
    002E9 DF8C      RCALL	_LCD_Comm
(0079)     LCD_delay(2);
    002EA E002      LDI	R16,2
    002EB CF5B      RJMP	_LCD_delay
(0080) }
(0081) 
(0082) void Cursor_Home(void) {
(0083)     LCD_Comm(0x02); // move LCD cursor to home
_Cursor_Home:
    002EC E002      LDI	R16,2
    002ED DF88      RCALL	_LCD_Comm
(0084)     LCD_delay(2);
    002EE E002      LDI	R16,2
    002EF CF57      RJMP	_LCD_delay
(0085) }
_Interrupt_init:
    002F0 B789      IN	R24,0x39
    002F1 6081      ORI	R24,1
    002F2 BF89      OUT	0x39,R24
    002EF CF57      RJMP	_LCD_delay
FILE: C:\Users\user\Desktop\hidden-catch\main.c
(0001) #include <iom128v.h>
(0002) #include "my128.h"
(0003) #include "lcd.h"
(0004) #include "cgram.h"
(0005) #include "utils.h"
(0006) 
(0007) unsigned int score = 0; // 점수 저장
(0008) 
(0009) // flags: start / quiz 1~8 sequence 진행중이면 1, 아직 진행 전이거나 완료되었으면 0
(0010) int start_flag = 0;
(0011) int q1_flag = 0;
(0012) int q2_flag = 0;
(0013) 
(0014) // 버튼 0~3으로 커서 이동 인터럽트 작성
(0015) 
(0016) void Interrupt_init(void) {
(0017)     EIMSK |= 1 << INT0;          // INT0 버튼 인터럽트 허용
_Interrupt_init:
    002F0 B789      IN	R24,0x39
    002F1 6081      ORI	R24,1
    002F2 BF89      OUT	0x39,R24
(0018)     EICRA |= 1 << ISC01 | 1 << ISC11 | 1 << ISC21 | 1 << ISC31;
    002F3 9180 006A LDS	R24,0x6A
    002F5 6A8A      ORI	R24,0xAA
    002F6 9380 006A STS	0x6A,R24
(0019)     // INT0~INT3 falling edge trigger 설정
(0020)     EICRB |= 1 << ISC41 | 1 << ISC51 | 1 << ISC61 | 1 << ISC71;
    002F8 B78A      IN	R24,0x3A
    002F9 6A8A      ORI	R24,0xAA
    002FA BF8A      OUT	0x3A,R24
(0021)     // INT4~INT7 falling edge trigger 설정
(0022)     SREG |= 0x80;           // 전역 인터럽트 허가
    002FB 9478      BSET	7
    002FC 9508      RET
(0023) }
(0024) 
(0025) void LCD_game_start(void) {
(0026)     if (start_flag) {
    002FD 9020 0102 LDS	R2,_start_flag
    002FF 9030 0103 LDS	R3,_start_flag+1
    00301 2022      TST	R2
    00302 F419      BNE	0x0306
    00303 2033      TST	R3
    00304 F409      BNE	0x0306
    00305 C044      RJMP	0x034A
(0027)         Cursor_Home();
    00306 940E 02EC CALL	_Cursor_Home
(0028)         LCD_STR("Starting in...");
    00308 E307      LDI	R16,0x37
    00309 E011      LDI	R17,1
    0030A 940E 02B0 CALL	_LCD_STR
(0029)         LCD_pos(0,15);
    0030C E02F      LDI	R18,0xF
    0030D 2700      CLR	R16
    0030E 940E 02C0 CALL	_LCD_pos
(0030)         LCD_STR("3");
    00310 E305      LDI	R16,0x35
    00311 E011      LDI	R17,1
    00312 940E 02B0 CALL	_LCD_STR
(0031)         delay_ms(1000);
    00314 EE08      LDI	R16,0xE8
    00315 E013      LDI	R17,3
    00316 940E 0433 CALL	_delay_ms
(0032) 
(0033)         LCD_pos(0,15);
    00318 E02F      LDI	R18,0xF
    00319 2700      CLR	R16
    0031A 940E 02C0 CALL	_LCD_pos
(0034)         LCD_STR("2");
    0031C E303      LDI	R16,0x33
    0031D E011      LDI	R17,1
    0031E 940E 02B0 CALL	_LCD_STR
(0035)         delay_ms(1000);
    00320 EE08      LDI	R16,0xE8
    00321 E013      LDI	R17,3
    00322 940E 0433 CALL	_delay_ms
(0036) 
(0037)         LCD_pos(0,15);
    00324 E02F      LDI	R18,0xF
    00325 2700      CLR	R16
    00326 940E 02C0 CALL	_LCD_pos
(0038)         LCD_STR("1");
    00328 E301      LDI	R16,0x31
    00329 E011      LDI	R17,1
    0032A 940E 02B0 CALL	_LCD_STR
(0039)         delay_ms(1000);
    0032C EE08      LDI	R16,0xE8
    0032D E013      LDI	R17,3
    0032E 940E 0433 CALL	_delay_ms
(0040) 
(0041)         LCD_Clear();
    00330 940E 02D0 CALL	_LCD_Clear
(0042)         Cursor_Home();
    00332 940E 02EC CALL	_Cursor_Home
(0043)         LCD_STR("GO!!!");
    00334 E20B      LDI	R16,0x2B
    00335 E011      LDI	R17,1
    00336 940E 02B0 CALL	_LCD_STR
(0044)         delay_ms(800);
    00338 E200      LDI	R16,0x20
    00339 E013      LDI	R17,3
    0033A 940E 0433 CALL	_delay_ms
(0045) 
(0046)         LCD_Clear();
    0033C 940E 02D0 CALL	_LCD_Clear
(0047)         start_flag = 0; // start sequence 종료
    0033E 2422      CLR	R2
    0033F 2433      CLR	R3
    00340 9230 0103 STS	_start_flag+1,R3
    00342 9220 0102 STS	_start_flag,R2
(0048)         q1_flag = 1;    // quiz1 sequence 시작
    00344 E081      LDI	R24,1
    00345 E090      LDI	R25,0
    00346 9390 0105 STS	_q1_flag+1,R25
    00348 9380 0104 STS	_q1_flag,R24
    0034A 9508      RET
(0049)     }
(0050) }
    0034B 940E 0592 CALL	push_xgsetF0FC
    0034D 9721      SBIW	R28,1
(0051) 
(0052) void Quiz_1(void) {     // 꽉 찬 CLCD의 문자들 중 다른 영어 문자 1개 찾기
(0053)     Cursor_Home();
    0034E 940E 02EC CALL	_Cursor_Home
(0054) 
(0055)     LCD_STR("AAAAAAAAAAAAAAAA");
    00350 E10A      LDI	R16,0x1A
    00351 E011      LDI	R17,1
    00352 940E 02B0 CALL	_LCD_STR
(0056)     LCD_pos(1,0);
    00354 2722      CLR	R18
    00355 E001      LDI	R16,1
    00356 940E 02C0 CALL	_LCD_pos
(0057)     LCD_STR("AAAAAAAAAAAAAAAA");
    00358 E10A      LDI	R16,0x1A
    00359 E011      LDI	R17,1
    0035A 940E 02B0 CALL	_LCD_STR
(0058)     // A 문자로 32칸 다 채움
(0059) 
(0060)     Byte answer_row = get_random(2);    // 0, 1행 중 랜덤 하나 선택
    0035C E002      LDI	R16,2
    0035D E010      LDI	R17,0
    0035E 940E 04F2 CALL	_get_random
    00360 8308      ST	Y,R16
(0061)     Byte answer_col = get_random(16);   // 0~15열 중 랜덤 하나 선택
    00361 E100      LDI	R16,0x10
    00362 E010      LDI	R17,0
    00363 940E 04F2 CALL	_get_random
    00365 2EC0      MOV	R12,R16
(0062) 
(0063)     LCD_pos(answer_row, answer_col);
    00366 2D2C      MOV	R18,R12
    00367 8108      LD	R16,Y
    00368 940E 02C0 CALL	_LCD_pos
(0064)     LCD_STR("B");               // 랜덤한 행,열에 B 문자 출력
    0036A E108      LDI	R16,0x18
    0036B E011      LDI	R17,1
    0036C 940E 02B0 CALL	_LCD_STR
(0065) 
(0066)     LCD_Comm(0x0E);             // lCD 커서 on (1번 문제 진행에 필요)
    0036E E00E      LDI	R16,0xE
    0036F 940E 0276 CALL	_LCD_Comm
(0067)     Cursor_Home();
    00371 940E 02EC CALL	_Cursor_Home
(0068) 
(0069)     Byte cursor_row = 0, cursor_col = 0;
    00373 2744      CLR	R20
    00374 2766      CLR	R22
    00375 C062      RJMP	0x03D8
(0070)     while (q1_flag == 1) {
(0071)         Byte D = PIND & 0xFF;
    00376 B380      IN	R24,0x10
    00377 7F8F      ANDI	R24,0xFF
    00378 2EE8      MOV	R14,R24
(0072)         switch (D) {
    00379 2EA8      MOV	R10,R24
    0037A 3B8F      CPI	R24,0xBF
    0037B F0C9      BEQ	0x0395
    0037C EB8F      LDI	R24,0xBF
    0037D 158E      CP	R24,R14
    0037E F020      BCS	0x0383
    0037F 2D8A      MOV	R24,R10
    00380 378F      CPI	R24,0x7F
    00381 F0C1      BEQ	0x039A
    00382 C01A      RJMP	0x039D
    00383 2D8A      MOV	R24,R10
    00384 3D8F      CPI	R24,0xDF
    00385 F059      BEQ	0x0391
    00386 3D8F      CPI	R24,0xDF
    00387 F0A8      BCS	0x039D
    00388 2D8A      MOV	R24,R10
    00389 3E8F      CPI	R24,0xEF
    0038A F009      BEQ	0x038C
    0038B C011      RJMP	0x039D
(0073)             case 0b11101111: if (cursor_row > 0) cursor_row--; break;   // PD4, move cursor up
    0038C 2422      CLR	R2
    0038D 1624      CP	R2,R20
    0038E F470      BCC	0x039D
    0038F 954A      DEC	R20
    00390 C00C      RJMP	0x039D
(0074)             case 0b11011111: if (cursor_row < 1) cursor_row++; break;   // PD5, move cursor down
    00391 3041      CPI	R20,1
    00392 F450      BCC	0x039D
    00393 9543      INC	R20
    00394 C008      RJMP	0x039D
(0075)             case 0b10111111: if (cursor_col > 0) cursor_col--; break;   // PD6, move cursor left
    00395 2422      CLR	R2
    00396 1626      CP	R2,R22
    00397 F428      BCC	0x039D
    00398 956A      DEC	R22
    00399 C003      RJMP	0x039D
(0076)             case 0b01111111: if (cursor_col < 15) cursor_col++; break;  // PD7, move cursor right
    0039A 306F      CPI	R22,0xF
    0039B F408      BCC	0x039D
    0039C 9563      INC	R22
(0077)         }
(0078) 
(0079)         LCD_pos(cursor_row, cursor_col);
    0039D 2F26      MOV	R18,R22
    0039E 2F04      MOV	R16,R20
    0039F 940E 02C0 CALL	_LCD_pos
(0080) 
(0081)         if (D == 0b11111101) {  // 사용자가 커서 이동 완료 후 정답 선택 버튼 (PD1) 눌렀을 때
    003A1 2D8E      MOV	R24,R14
    003A2 3F8D      CPI	R24,0xFD
    003A3 F581      BNE	0x03D4
(0082)             if (cursor_row == answer_row && cursor_col == answer_col) {
    003A4 8008      LD	R0,Y
    003A5 1540      CP	R20,R0
    003A6 F4F1      BNE	0x03C5
    003A7 156C      CP	R22,R12
    003A8 F4E1      BNE	0x03C5
(0083)                 // 만약 정답 위치와 커서 위치 일치 시 정답
(0084)                 q1_flag = 0; score++;   // quiz1 flag 내림 (q1 sequence 종료), score 증가
    003A9 2422      CLR	R2
    003AA 2433      CLR	R3
    003AB 9230 0105 STS	_q1_flag+1,R3
    003AD 9220 0104 STS	_q1_flag,R2
    003AF 9180 0100 LDS	R24,_score
    003B1 9190 0101 LDS	R25,_score+1
    003B3 9601      ADIW	R24,1
    003B4 9390 0101 STS	_score+1,R25
    003B6 9380 0100 STS	_score,R24
(0085)                 LCD_Clear(); Cursor_Home(); LCD_STR("Correct!");    // 정답 메세지 출력
    003B8 940E 02D0 CALL	_LCD_Clear
    003BA 940E 02EC CALL	_Cursor_Home
    003BC E00F      LDI	R16,0xF
    003BD E011      LDI	R17,1
    003BE 940E 02B0 CALL	_LCD_STR
(0086)                 LED_correct(); LCD_Clear(); // LED 점등, 이후 LCD clear, 커서 제거
    003C0 940E 0461 CALL	_LED_correct
    003C2 940E 02D0 CALL	_LCD_Clear
(0087)                 break;
    003C4 C01C      RJMP	0x03E1
(0088)             }
(0089)             else {
(0090)             // 아니면 오답 처리 후 새로운 문제 출제
(0091)                 LCD_Clear(); Cursor_Home(); LCD_STR("Wrong!");  // 오답 메시지 출력
    003C5 940E 02D0 CALL	_LCD_Clear
    003C7 940E 02EC CALL	_Cursor_Home
    003C9 E008      LDI	R16,0x8
    003CA E011      LDI	R17,1
    003CB 940E 02B0 CALL	_LCD_STR
(0092)                 delay_ms(1000); LCD_Clear(); Quiz_1();  // LCD clear 후 새 문제 출제
    003CD EE08      LDI	R16,0xE8
    003CE E013      LDI	R17,3
    003CF 940E 0433 CALL	_delay_ms
    003D1 940E 02D0 CALL	_LCD_Clear
    003D3 DF77      RCALL	_Quiz_1
(0093)             }
(0094)         }
(0095) 
(0096)         delay_ms(100); // 버튼 입력 간 딜레이 조절 가능
    003D4 E604      LDI	R16,0x64
    003D5 E010      LDI	R17,0
    003D6 940E 0433 CALL	_delay_ms
    003D8 9180 0104 LDS	R24,_q1_flag
    003DA 9190 0105 LDS	R25,_q1_flag+1
    003DC 3081      CPI	R24,1
    003DD E0E0      LDI	R30,0
    003DE 079E      CPC	R25,R30
    003DF F409      BNE	0x03E1
    003E0 CF95      RJMP	0x0376
(0097)     }
(0098)     // 문제 출제 종료 (A,B) 더이상 출력하지 않게 설정
(0099) 
(0100)     LCD_Comm(0x0C);     // LCD 커서 off
    003E1 E00C      LDI	R16,0xC
    003E2 940E 0276 CALL	_LCD_Comm
(0101)     Cursor_Home();      // lCD 커서 홈으로 이동
    003E4 940E 02EC CALL	_Cursor_Home
(0102) }
    003E6 9621      ADIW	R28,1
    003E7 940C 0587 JMP	pop_xgsetF0FC
    003E9 9508      RET
(0103) 
(0104) void Quiz_2(void) {
    003EA 940C 02EC JMP	_Cursor_Home
(0105)     // CGROM- '식': 0x00, '사': 0x01, '샤': 0x02
(0106) 
(0107)     Cursor_Home();
(0108) }
(0109) 
(0110) void main(void) {
(0111)     DDRB = 0xFF;        // PORTB 출력 모드 (LED)
    003EC EF8F      LDI	R24,0xFF
    003ED BB87      OUT	0x17,R24
(0112)     PORTB = 0xFF;       // LED 전체 off
    003EE BB88      OUT	0x18,R24
(0113) 
(0114)     DDRD = 0xFF;        // PORTD 출력 모드 (버튼)
    003EF BB81      OUT	0x11,R24
(0115)     PORTD = 0xFF;       // PORTD 내부 풀업 저항 사용하기 위해 Set
    003F0 BB82      OUT	0x12,R24
(0116)     SFIOR |= 0x04;      // PUD bit 1로 설정
    003F1 B580      IN	R24,0x20
    003F2 6084      ORI	R24,4
    003F3 BD80      OUT	0x20,R24
(0117) 
(0118)     Interrupt_init();
    003F4 DEFB      RCALL	_Interrupt_init
(0119)     PortInit();
    003F5 940E 024F CALL	_PortInit
(0120)     LCD_Init();
    003F7 940E 02D4 CALL	_LCD_Init
(0121) 
(0122)     CGRAM_set_menu();
    003F9 940E 00D9 CALL	_CGRAM_set_menu
(0123)     Cursor_Home();
    003FB 940E 02EC CALL	_Cursor_Home
(0124)     LCD_menu();
    003FD 940E 01C8 CALL	_LCD_menu
(0125)     delay_ms(10);
    003FF E00A      LDI	R16,0xA
    00400 E010      LDI	R17,0
    00401 940E 0433 CALL	_delay_ms
    00403 C02D      RJMP	0x0431
(0126) 
(0127)     while (1) {
(0128)         if ((PIND & 0xFF) == 0b01111111) {  // PD7 눌러서 퀴즈 시작
    00404 B380      IN	R24,0x10
    00405 7F8F      ANDI	R24,0xFF
    00406 378F      CPI	R24,0x7F
    00407 F439      BNE	0x040F
(0129)             // 테스트할 때에는 rxdata == 'A'로 변경
(0130)             start_flag = 1;
    00408 E081      LDI	R24,1
    00409 E090      LDI	R25,0
    0040A 9390 0103 STS	_start_flag+1,R25
    0040C 9380 0102 STS	_start_flag,R24
(0131)             LCD_game_start();
    0040E DEEE      RCALL	_LCD_game_start
(0132)         }
(0133)         if (start_flag == 0 && q1_flag == 1)
    0040F 9020 0102 LDS	R2,_start_flag
    00411 9030 0103 LDS	R3,_start_flag+1
    00413 2022      TST	R2
    00414 F459      BNE	0x0420
    00415 2033      TST	R3
    00416 F449      BNE	0x0420
    00417 9180 0104 LDS	R24,_q1_flag
    00419 9190 0105 LDS	R25,_q1_flag+1
    0041B 3081      CPI	R24,1
    0041C E0E0      LDI	R30,0
    0041D 079E      CPC	R25,R30
    0041E F409      BNE	0x0420
(0134)             Quiz_1();
    0041F DF2B      RCALL	_Quiz_1
(0135)         if (start_flag == 0 && q2_flag == 1)
    00420 9020 0102 LDS	R2,_start_flag
    00422 9030 0103 LDS	R3,_start_flag+1
    00424 2022      TST	R2
    00425 F459      BNE	0x0431
    00426 2033      TST	R3
    00427 F449      BNE	0x0431
    00428 9180 0106 LDS	R24,_q2_flag
    0042A 9190 0107 LDS	R25,_q2_flag+1
    0042C 3081      CPI	R24,1
    0042D E0E0      LDI	R30,0
    0042E 079E      CPC	R25,R30
    0042F F409      BNE	0x0431
(0136)             Quiz_2();
    00430 DFB9      RCALL	_Quiz_2
    00431 CFD2      RJMP	0x0404
    00432 9508      RET
(0137)     }
(0138) 
(0139) }
    00433 940E 059D CALL	push_xgsetF000
    00434 059D      CPC	R25,R13
FILE: C:\Users\user\Desktop\hidden-catch\my128.c
(0001) #include "my128.h"
(0002) 
(0003) void delay_ms(unsigned int m) {
(0004)     unsigned int i, j;
(0005)     
(0006)     for (i = 0; i < m; i++)
    00435 2744      CLR	R20
    00436 2755      CLR	R21
    00437 C00C      RJMP	0x0444
(0007)         for (j = 0; j < 2130; j++)
    00438 2766      CLR	R22
    00439 2777      CLR	R23
    0043A C002      RJMP	0x043D
    0043B 5F6F      SUBI	R22,0xFF
    0043C 4F7F      SBCI	R23,0xFF
    0043D E582      LDI	R24,0x52
    0043E E098      LDI	R25,0x8
    0043F 1768      CP	R22,R24
    00440 0779      CPC	R23,R25
    00441 F3C8      BCS	0x043B
    00442 5F4F      SUBI	R20,0xFF
    00443 4F5F      SBCI	R21,0xFF
    00444 1740      CP	R20,R16
    00445 0751      CPC	R21,R17
    00446 F388      BCS	0x0438
    00447 940C 05A2 JMP	pop_xgsetF000
    00449 9508      RET
(0008)             ;
(0009) }   // delay_ms definition
_delay_us:
  i                    --> R20
  j                    --> R22
  m                    --> R16
    0044A 940E 059D CALL	push_xgsetF000
(0010) 
(0011) void delay_us(unsigned int m) {
(0012)     unsigned int i, j;
(0013) 
(0014)     for (i = 0; i < m; i++)
    0044C 2744      CLR	R20
    0044D 2755      CLR	R21
    0044E C00C      RJMP	0x045B
(0015)         for (j = 0; j < 2; j++)
    0044F 2766      CLR	R22
    00450 2777      CLR	R23
    00451 C002      RJMP	0x0454
    00452 5F6F      SUBI	R22,0xFF
    00453 4F7F      SBCI	R23,0xFF
    00454 E082      LDI	R24,2
    00455 E090      LDI	R25,0
    00456 1768      CP	R22,R24
    00457 0779      CPC	R23,R25
    00458 F3C8      BCS	0x0452
    00459 5F4F      SUBI	R20,0xFF
    0045A 4F5F      SBCI	R21,0xFF
    0045B 1740      CP	R20,R16
    0045C 0751      CPC	R21,R17
    0045D F388      BCS	0x044F
    0045E 940C 05A2 JMP	pop_xgsetF000
    00460 9508      RET
(0016)             ;
(0017) }   // delay_us definition
_LED_correct:
    00461 2422      CLR	R2
    00462 BA28      OUT	0x18,R2
    0045C 0751      CPC	R21,R17
    0045D F388      BCS	0x044F
    0045E 940C 05A2 JMP	pop_xgsetF000
    00460 9508      RET
FILE: C:\Users\user\Desktop\hidden-catch\utils.c
(0001) #include "utils.h"
(0002) 
(0003) void LED_correct(void) {  // 정답 시 LED 전체 점등 함수
(0004)     PORTB = 0x00; delay_ms(250);
_LED_correct:
    00461 2422      CLR	R2
    00462 BA28      OUT	0x18,R2
    00463 EF0A      LDI	R16,0xFA
    00464 E010      LDI	R17,0
    00465 940E 0433 CALL	_delay_ms
(0005)     PORTB = 0xFF; delay_ms(250);
    00467 EF8F      LDI	R24,0xFF
    00468 BB88      OUT	0x18,R24
    00469 EF0A      LDI	R16,0xFA
    0046A E010      LDI	R17,0
    0046B 940E 0433 CALL	_delay_ms
(0006)     PORTB = 0x00; delay_ms(250);
    0046D 2422      CLR	R2
    0046E BA28      OUT	0x18,R2
    0046F EF0A      LDI	R16,0xFA
    00470 E010      LDI	R17,0
    00471 940E 0433 CALL	_delay_ms
(0007)     PORTB = 0xFF; delay_ms(250);
    00473 EF8F      LDI	R24,0xFF
    00474 BB88      OUT	0x18,R24
    00475 EF0A      LDI	R16,0xFA
    00476 E010      LDI	R17,0
    00477 940C 0433 JMP	_delay_ms
(0008) }
    00479 922A      ST	-Y,R2
    0047A B62F      IN	R2,0x3F
    0047B 922A      ST	-Y,R2
(0009) 
(0010) Byte txdata = 0;    // 게임 종료 시 'B' 전송
(0011) Byte rxdata = 0;    // 'A' 수신 시 게임 시작
(0012) 
(0013) #pragma interrupt_handler usart0_transmit: iv_USART0_DRE
(0014) void usart0_transmit(void) { UDR0 = txdata; }
    0047C 9020 0146 LDS	R2,_txdata
    0047E B82C      OUT	0x0C,R2
    0047F 9029      LD	R2,Y+
    00480 BE2F      OUT	0x3F,R2
    00481 9029      LD	R2,Y+
    00482 9518      RETI
    00483 922A      ST	-Y,R2
    00484 B62F      IN	R2,0x3F
    00485 922A      ST	-Y,R2
(0015) 
(0016) #pragma interrupt_handler usart0_receive: iv_USART0_RXC
(0017) void usart0_receive(void) { rxdata = UDR0; }
    00486 B02C      IN	R2,0x0C
    00487 9220 0147 STS	_rxdata,R2
    00489 9029      LD	R2,Y+
    0048A BE2F      OUT	0x3F,R2
    0048B 9029      LD	R2,Y+
    0048C 9518      RETI
(0018) 
(0019) void Init_USART0(void) {
(0020)     UCSR0A &= ~(1 << U2X0); // 1배속 통신
    0048D 9859      CBI	0x0B,1
(0021) 
(0022)     UCSR0B = (1 << RXCIE0) | (1 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0);
    0048E EB88      LDI	R24,0xB8
    0048F B98A      OUT	0x0A,R24
(0023)     // 송/수신 및 송/수신 인터럽트 허가
(0024)     UCSR0C = (1 << UPM01) | (1 << UCSZ01) | (1 << UCSZ00);
    00490 E286      LDI	R24,0x26
    00491 9380 0095 STS	0x95,R24
(0025)     // 비동기식 통신, 짝수 패리티, 1bit stop bit, 8bit data
(0026) 
(0027)     UBRR0H = 0x00;
    00493 2422      CLR	R2
    00494 9220 0090 STS	0x90,R2
(0028)     UBRR0L = 0x67; // baud rate 9,600bps
    00496 E687      LDI	R24,0x67
    00497 B989      OUT	0x09,R24
(0029) 
(0030)     SREG |= 0x80;  // allow all interrupts
    00498 9478      BSET	7
    00499 9508      RET
(0031) }
(0032) 
(0033) void Init_Timer2(void) {
(0034)     TCCR2 = (1 << WGM21) | (1 << CS22) | (1 << CS21);   // CTC 모드, 분주비 256
    0049A E08E      LDI	R24,0xE
    0049B BD85      OUT	0x25,R24
(0035)     OCR2 = 250;
    0049C EF8A      LDI	R24,0xFA
    0049D BD83      OUT	0x23,R24
(0036)     TIMSK |= (1 << OCIE2);
    0049E B787      IN	R24,0x37
    0049F 6880      ORI	R24,0x80
    004A0 BF87      OUT	0x37,R24
(0037)     TCNT2 = 0;
    004A1 2422      CLR	R2
    004A2 BC24      OUT	0x24,R2
    004A3 9508      RET
(0038) }
    004A4 922A      ST	-Y,R2
    004A5 923A      ST	-Y,R3
    004A6 924A      ST	-Y,R4
    004A7 925A      ST	-Y,R5
    004A8 938A      ST	-Y,R24
    004A9 939A      ST	-Y,R25
    004AA 93AA      ST	-Y,R26
    004AB 93BA      ST	-Y,R27
    004AC B62F      IN	R2,0x3F
    004AD 922A      ST	-Y,R2
(0039) 
(0040) #pragma interrupt_handler timer2_comp_isr: iv_TIM2_COMP
(0041) unsigned long long random_seed = 0;     // random seed (8 bytes)
(0042) unsigned long long n = 0;
(0043) 
(0044) void timer2_comp_isr(void) {
(0045)     random_seed++;
    004AE E081      LDI	R24,1
    004AF E090      LDI	R25,0
    004B0 E0A0      LDI	R26,0
    004B1 E0B0      LDI	R27,0
    004B2 9040 014A LDS	R4,_random_seed+2
    004B4 9050 014B LDS	R5,_random_seed+3
    004B6 9020 0148 LDS	R2,_random_seed
    004B8 9030 0149 LDS	R3,_random_seed+1
    004BA 0E28      ADD	R2,R24
    004BB 1E39      ADC	R3,R25
    004BC 1E4A      ADC	R4,R26
    004BD 1E5B      ADC	R5,R27
    004BE 9230 0149 STS	_random_seed+1,R3
    004C0 9220 0148 STS	_random_seed,R2
    004C2 9250 014B STS	_random_seed+3,R5
    004C4 9240 014A STS	_random_seed+2,R4
(0046)     if (random_seed > 500) n++;
    004C6 EF84      LDI	R24,0xF4
    004C7 E091      LDI	R25,1
    004C8 E0A0      LDI	R26,0
    004C9 E0B0      LDI	R27,0
    004CA 1582      CP	R24,R2
    004CB 0593      CPC	R25,R3
    004CC 05A4      CPC	R26,R4
    004CD 05B5      CPC	R27,R5
    004CE F4C0      BCC	0x04E7
    004CF E081      LDI	R24,1
    004D0 E090      LDI	R25,0
    004D1 E0A0      LDI	R26,0
    004D2 E0B0      LDI	R27,0
    004D3 9040 014E LDS	R4,_n+2
    004D5 9050 014F LDS	R5,_n+3
    004D7 9020 014C LDS	R2,_n
    004D9 9030 014D LDS	R3,_n+1
    004DB 0E28      ADD	R2,R24
    004DC 1E39      ADC	R3,R25
    004DD 1E4A      ADC	R4,R26
    004DE 1E5B      ADC	R5,R27
    004DF 9230 014D STS	_n+1,R3
    004E1 9220 014C STS	_n,R2
    004E3 9250 014F STS	_n+3,R5
    004E5 9240 014E STS	_n+2,R4
    004E7 9029      LD	R2,Y+
    004E8 BE2F      OUT	0x3F,R2
    004E9 91B9      LD	R27,Y+
    004EA 91A9      LD	R26,Y+
    004EB 9199      LD	R25,Y+
    004EC 9189      LD	R24,Y+
    004ED 9059      LD	R5,Y+
    004EE 9049      LD	R4,Y+
    004EF 9039      LD	R3,Y+
    004F0 9029      LD	R2,Y+
    004F1 9518      RETI
(0047) } // random_seed++ every 4ms
    004F2 92AA      ST	-Y,R10
    004F3 92BA      ST	-Y,R11
    004F4 0158      MOVW	R10,R16
(0048) 
(0049) int get_random(int max) { return n % max; }
    004F5 0115      MOVW	R2,R10
    004F6 2444      CLR	R4
    004F7 FC37      SBRC	R3,7
    004F8 9440      COM	R4
    004F9 2455      CLR	R5
    004FA FC47      SBRC	R4,7
    004FB 9450      COM	R5
    004FC 9120 014E LDS	R18,_n+2
    004FE 9130 014F LDS	R19,_n+3
    00500 9100 014C LDS	R16,_n
    00502 9110 014D LDS	R17,_n+1
    00504 925A      ST	-Y,R5
    00505 924A      ST	-Y,R4
    00506 923A      ST	-Y,R3
    00507 922A      ST	-Y,R2
    00508 940E 050F CALL	mod32u
    0050A 90B9      LD	R11,Y+
    0050B 90A9      LD	R10,Y+
    0050C 9508      RET
    0050D 94E8      BCLR	6
    0050E C001      RJMP	0x0510
