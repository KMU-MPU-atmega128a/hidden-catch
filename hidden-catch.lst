NOTE: Code bytes are displayed in order matching the disassembly format in AVR documentation.
  For example, 'CALL 2B16' (example only, only labels should normally be used) is displayed as
  0x940E2B16 rather than in little endian byte order.

Interrupt Vectors

Program Code (text area)
_CGRAM_set_menu:
  i                    --> R20
  i                    --> R20
  i                    --> R20
  i                    --> R20
  i                    --> R20
  i                    --> R20
  menu6                --> Y,+40
  menu5                --> Y,+32
  menu4                --> Y,+24
  menu3                --> Y,+16
  menu2                --> Y,+8
  menu1                --> Y,+0
    000D7 934A      ST	-Y,R20
    000D8 935A      ST	-Y,R21
    000D9 97E0      SBIW	R28,0x30
FILE: C:\Users\user\Desktop\hidden-catch\cgram.c
(0001) #include "cgram.h"
(0002) 
(0003) void CGRAM_set_menu(void) { // 초기 화면 함수 ("다른문자찾기" 출력)
(0004)     Byte menu1[] = {0x02, 0x1E, 0x12, 0x13, 0x12, 0x1E, 0x02, 0x02};
    000DA ED84      LDI	R24,0xD4
    000DB E090      LDI	R25,0
    000DC 01FE      MOVW	R30,R28
    000DD E008      LDI	R16,0x8
    000DE E010      LDI	R17,0
    000DF 93FA      ST	-Y,R31
    000E0 93EA      ST	-Y,R30
    000E1 939A      ST	-Y,R25
    000E2 938A      ST	-Y,R24
    000E3 940E 058D CALL	asgncblkx
(0005)     Byte menu2[] = {0x0E, 0x02, 0x0E, 0x08, 0x0E, 0x1F, 0x08, 0x0E};
    000E5 ED8C      LDI	R24,0xDC
    000E6 E090      LDI	R25,0
    000E7 01FE      MOVW	R30,R28
    000E8 9638      ADIW	R30,0x8
    000E9 E008      LDI	R16,0x8
    000EA E010      LDI	R17,0
    000EB 93FA      ST	-Y,R31
    000EC 93EA      ST	-Y,R30
    000ED 939A      ST	-Y,R25
    000EE 938A      ST	-Y,R24
    000EF 940E 058D CALL	asgncblkx
(0006)     Byte menu3[] = {0x0E, 0x0A, 0x0E, 0x00, 0x1F, 0x04, 0x08, 0x0E};
    000F1 EE84      LDI	R24,0xE4
    000F2 E090      LDI	R25,0
    000F3 01FE      MOVW	R30,R28
    000F4 9670      ADIW	R30,0x10
    000F5 E008      LDI	R16,0x8
    000F6 E010      LDI	R17,0
    000F7 93FA      ST	-Y,R31
    000F8 93EA      ST	-Y,R30
    000F9 939A      ST	-Y,R25
    000FA 938A      ST	-Y,R24
    000FB 940E 058D CALL	asgncblkx
(0007)     Byte menu4[] = {0x02, 0x1E, 0x0A, 0x17, 0x16, 0x02, 0x02, 0x00};
    000FD EE8C      LDI	R24,0xEC
    000FE E090      LDI	R25,0
    000FF 01FE      MOVW	R30,R28
    00100 9678      ADIW	R30,0x18
    00101 E008      LDI	R16,0x8
    00102 E010      LDI	R17,0
    00103 93FA      ST	-Y,R31
    00104 93EA      ST	-Y,R30
    00105 939A      ST	-Y,R25
    00106 938A      ST	-Y,R24
    00107 940E 058D CALL	asgncblkx
(0008)     Byte menu5[] = {0x0A, 0x1E, 0x0B, 0x16, 0x02, 0x0E, 0x04, 0x0A};
    00109 EF84      LDI	R24,0xF4
    0010A E090      LDI	R25,0
    0010B 01FE      MOVW	R30,R28
    0010C 96B0      ADIW	R30,0x20
    0010D E008      LDI	R16,0x8
    0010E E010      LDI	R17,0
    0010F 93FA      ST	-Y,R31
    00110 93EA      ST	-Y,R30
    00111 939A      ST	-Y,R25
    00112 938A      ST	-Y,R24
    00113 940E 058D CALL	asgncblkx
(0009)     Byte menu6[] = {0x02, 0x1A, 0x0A, 0x0A, 0x0A, 0x0A, 0x02, 0x02};
    00115 EF8C      LDI	R24,0xFC
    00116 E090      LDI	R25,0
    00117 01FE      MOVW	R30,R28
    00118 96B8      ADIW	R30,0x28
    00119 E008      LDI	R16,0x8
    0011A E010      LDI	R17,0
    0011B 93FA      ST	-Y,R31
    0011C 93EA      ST	-Y,R30
    0011D 939A      ST	-Y,R25
    0011E 938A      ST	-Y,R24
    0011F 940E 058D CALL	asgncblkx
(0010) 
(0011)     LCD_Comm(0x40); // CGRAM 주소: 0b01 000000
    00121 E400      LDI	R16,0x40
    00122 940E 0274 CALL	_LCD_Comm
(0012)     LCD_delay(1);
    00124 E001      LDI	R16,1
    00125 940E 0245 CALL	_LCD_delay
(0013)     for (int i = 0; i < 8; i++) {
    00127 2744      CLR	R20
    00128 2755      CLR	R21
    00129 C00C      RJMP	0x0136
(0014)         LCD_Data(menu1[i]);
    0012A 01CE      MOVW	R24,R28
    0012B 01FA      MOVW	R30,R20
    0012C 0FE8      ADD	R30,R24
    0012D 1FF9      ADC	R31,R25
    0012E 8100      LD	R16,Z
    0012F 940E 0253 CALL	_LCD_Data
(0015)         LCD_delay(1);
    00131 E001      LDI	R16,1
    00132 940E 0245 CALL	_LCD_delay
    00134 5F4F      SUBI	R20,0xFF
    00135 4F5F      SBCI	R21,0xFF
    00136 E088      LDI	R24,0x8
    00137 E090      LDI	R25,0
    00138 1748      CP	R20,R24
    00139 0759      CPC	R21,R25
    0013A F37C      BLT	0x012A
(0016)     }
(0017) 
(0018)     LCD_Comm(0x48); // CGRAM 주소: 0b01 001000
    0013B E408      LDI	R16,0x48
    0013C 940E 0274 CALL	_LCD_Comm
(0019)     LCD_delay(1);
    0013E E001      LDI	R16,1
    0013F 940E 0245 CALL	_LCD_delay
(0020)     for (int i = 0; i < 8; i++) {
    00141 2744      CLR	R20
    00142 2755      CLR	R21
    00143 C00D      RJMP	0x0151
(0021)         LCD_Data(menu2[i]);
    00144 01CE      MOVW	R24,R28
    00145 9608      ADIW	R24,0x8
    00146 01FA      MOVW	R30,R20
    00147 0FE8      ADD	R30,R24
    00148 1FF9      ADC	R31,R25
    00149 8100      LD	R16,Z
    0014A 940E 0253 CALL	_LCD_Data
(0022)         LCD_delay(1);
    0014C E001      LDI	R16,1
    0014D 940E 0245 CALL	_LCD_delay
    0014F 5F4F      SUBI	R20,0xFF
    00150 4F5F      SBCI	R21,0xFF
    00151 E088      LDI	R24,0x8
    00152 E090      LDI	R25,0
    00153 1748      CP	R20,R24
    00154 0759      CPC	R21,R25
    00155 F374      BLT	0x0144
(0023)     }
(0024) 
(0025)     LCD_Comm(0x50); // CGRAM 주소: 0b01 010000
    00156 E500      LDI	R16,0x50
    00157 940E 0274 CALL	_LCD_Comm
(0026)     LCD_delay(1);
    00159 E001      LDI	R16,1
    0015A 940E 0245 CALL	_LCD_delay
(0027)     for (int i = 0; i < 8; i++) {
    0015C 2744      CLR	R20
    0015D 2755      CLR	R21
    0015E C00D      RJMP	0x016C
(0028)         LCD_Data(menu3[i]);
    0015F 01CE      MOVW	R24,R28
    00160 9640      ADIW	R24,0x10
    00161 01FA      MOVW	R30,R20
    00162 0FE8      ADD	R30,R24
    00163 1FF9      ADC	R31,R25
    00164 8100      LD	R16,Z
    00165 940E 0253 CALL	_LCD_Data
(0029)         LCD_delay(1);
    00167 E001      LDI	R16,1
    00168 940E 0245 CALL	_LCD_delay
    0016A 5F4F      SUBI	R20,0xFF
    0016B 4F5F      SBCI	R21,0xFF
    0016C E088      LDI	R24,0x8
    0016D E090      LDI	R25,0
    0016E 1748      CP	R20,R24
    0016F 0759      CPC	R21,R25
    00170 F374      BLT	0x015F
(0030)     }
(0031) 
(0032)     LCD_Comm(0x58); // CGRAM 주소: 0b01 011000
    00171 E508      LDI	R16,0x58
    00172 940E 0274 CALL	_LCD_Comm
(0033)     LCD_delay(1);
    00174 E001      LDI	R16,1
    00175 940E 0245 CALL	_LCD_delay
(0034)     for (int i = 0; i < 8; i++) {
    00177 2744      CLR	R20
    00178 2755      CLR	R21
    00179 C00D      RJMP	0x0187
(0035)         LCD_Data(menu4[i]);
    0017A 01CE      MOVW	R24,R28
    0017B 9648      ADIW	R24,0x18
    0017C 01FA      MOVW	R30,R20
    0017D 0FE8      ADD	R30,R24
    0017E 1FF9      ADC	R31,R25
    0017F 8100      LD	R16,Z
    00180 940E 0253 CALL	_LCD_Data
(0036)         LCD_delay(1);
    00182 E001      LDI	R16,1
    00183 940E 0245 CALL	_LCD_delay
    00185 5F4F      SUBI	R20,0xFF
    00186 4F5F      SBCI	R21,0xFF
    00187 E088      LDI	R24,0x8
    00188 E090      LDI	R25,0
    00189 1748      CP	R20,R24
    0018A 0759      CPC	R21,R25
    0018B F374      BLT	0x017A
(0037)     }
(0038) 
(0039)     LCD_Comm(0x60); // CGRAM 주소: 0b01 100000
    0018C E600      LDI	R16,0x60
    0018D 940E 0274 CALL	_LCD_Comm
(0040)     LCD_delay(1);
    0018F E001      LDI	R16,1
    00190 940E 0245 CALL	_LCD_delay
(0041)     for (int i = 0; i < 8; i++) {
    00192 2744      CLR	R20
    00193 2755      CLR	R21
    00194 C00D      RJMP	0x01A2
(0042)         LCD_Data(menu5[i]);
    00195 01CE      MOVW	R24,R28
    00196 9680      ADIW	R24,0x20
    00197 01FA      MOVW	R30,R20
    00198 0FE8      ADD	R30,R24
    00199 1FF9      ADC	R31,R25
    0019A 8100      LD	R16,Z
    0019B 940E 0253 CALL	_LCD_Data
(0043)         LCD_delay(1);
    0019D E001      LDI	R16,1
    0019E 940E 0245 CALL	_LCD_delay
    001A0 5F4F      SUBI	R20,0xFF
    001A1 4F5F      SBCI	R21,0xFF
    001A2 E088      LDI	R24,0x8
    001A3 E090      LDI	R25,0
    001A4 1748      CP	R20,R24
    001A5 0759      CPC	R21,R25
    001A6 F374      BLT	0x0195
(0044)     }
(0045) 
(0046)     LCD_Comm(0x68); // CGRAM 주소: 0b01 101000
    001A7 E608      LDI	R16,0x68
    001A8 940E 0274 CALL	_LCD_Comm
(0047)     LCD_delay(1);
    001AA E001      LDI	R16,1
    001AB 940E 0245 CALL	_LCD_delay
(0048)     for (int i = 0; i < 8; i++) {
    001AD 2744      CLR	R20
    001AE 2755      CLR	R21
    001AF C00D      RJMP	0x01BD
(0049)         LCD_Data(menu6[i]);
    001B0 01CE      MOVW	R24,R28
    001B1 9688      ADIW	R24,0x28
    001B2 01FA      MOVW	R30,R20
    001B3 0FE8      ADD	R30,R24
    001B4 1FF9      ADC	R31,R25
    001B5 8100      LD	R16,Z
    001B6 940E 0253 CALL	_LCD_Data
(0050)         LCD_delay(1);
    001B8 E001      LDI	R16,1
    001B9 940E 0245 CALL	_LCD_delay
    001BB 5F4F      SUBI	R20,0xFF
    001BC 4F5F      SBCI	R21,0xFF
    001BD E088      LDI	R24,0x8
    001BE E090      LDI	R25,0
    001BF 1748      CP	R20,R24
    001C0 0759      CPC	R21,R25
    001C1 F374      BLT	0x01B0
    001C2 96E0      ADIW	R28,0x30
    001C3 9159      LD	R21,Y+
    001C4 9149      LD	R20,Y+
    001C5 9508      RET
(0051)     }
(0052) }
_LCD_menu:
  i                    --> R20
    001C6 934A      ST	-Y,R20
(0053) 
(0054) void LCD_menu(void) {   // 초기 문자 "다른문자찾기" LCD에 출력
(0055)     for (Byte i = 0x00; i < 0x06; i++) {
    001C7 2744      CLR	R20
    001C8 C007      RJMP	0x01D0
(0056)         LCD_Data(i);
    001C9 2F04      MOV	R16,R20
    001CA 940E 0253 CALL	_LCD_Data
(0057)         LCD_delay(1);
    001CC E001      LDI	R16,1
    001CD 940E 0245 CALL	_LCD_delay
    001CF 9543      INC	R20
    001D0 3046      CPI	R20,6
    001D1 F3B8      BCS	0x01C9
    001D2 9149      LD	R20,Y+
    001D3 9508      RET
(0058)     }
(0059) }
_CGRAM_set_quiz2:
  i                    --> R20
  i                    --> R20
  i                    --> R20
  q2_3                 --> Y,+16
  q2_2                 --> Y,+8
  q2_1                 --> Y,+0
    001D4 934A      ST	-Y,R20
    001D5 935A      ST	-Y,R21
    001D6 9768      SBIW	R28,0x18
(0060) 
(0061) void CGRAM_set_quiz2(void) {
(0062)     Byte q2_1[] = {0x09, 0x09, 0x09, 0x15, 0x01, 0x0E, 0x02, 0x02}; // '식'
    001D7 E084      LDI	R24,4
    001D8 E091      LDI	R25,1
    001D9 01FE      MOVW	R30,R28
    001DA E008      LDI	R16,0x8
    001DB E010      LDI	R17,0
    001DC 93FA      ST	-Y,R31
    001DD 93EA      ST	-Y,R30
    001DE 939A      ST	-Y,R25
    001DF 938A      ST	-Y,R24
    001E0 940E 058D CALL	asgncblkx
(0063)     Byte q2_2[] = {0x02, 0x0A, 0x0A, 0x0B, 0x16, 0x02, 0x02, 0x02}; // '사'
    001E2 E08C      LDI	R24,0xC
    001E3 E091      LDI	R25,1
    001E4 01FE      MOVW	R30,R28
    001E5 9638      ADIW	R30,0x8
    001E6 E008      LDI	R16,0x8
    001E7 E010      LDI	R17,0
    001E8 93FA      ST	-Y,R31
    001E9 93EA      ST	-Y,R30
    001EA 939A      ST	-Y,R25
    001EB 938A      ST	-Y,R24
    001EC 940E 058D CALL	asgncblkx
(0064)     Byte q2_3[] = {0x02, 0x0A, 0x0B, 0x16, 0x17, 0x02, 0x02, 0x02}; // '샤'
    001EE E184      LDI	R24,0x14
    001EF E091      LDI	R25,1
    001F0 01FE      MOVW	R30,R28
    001F1 9670      ADIW	R30,0x10
    001F2 E008      LDI	R16,0x8
    001F3 E010      LDI	R17,0
    001F4 93FA      ST	-Y,R31
    001F5 93EA      ST	-Y,R30
    001F6 939A      ST	-Y,R25
    001F7 938A      ST	-Y,R24
    001F8 940E 058D CALL	asgncblkx
(0065) 
(0066)     LCD_Comm(0x40);     // CGRAM 주소: 0b01 000000
    001FA E400      LDI	R16,0x40
    001FB 940E 0274 CALL	_LCD_Comm
(0067)     for (int i = 0; i < 8; i++) {
    001FD 2744      CLR	R20
    001FE 2755      CLR	R21
    001FF C00C      RJMP	0x020C
(0068)         LCD_Data(q2_1[i]);
    00200 01CE      MOVW	R24,R28
    00201 01FA      MOVW	R30,R20
    00202 0FE8      ADD	R30,R24
    00203 1FF9      ADC	R31,R25
    00204 8100      LD	R16,Z
    00205 940E 0253 CALL	_LCD_Data
(0069)         LCD_delay(1);
    00207 E001      LDI	R16,1
    00208 940E 0245 CALL	_LCD_delay
    0020A 5F4F      SUBI	R20,0xFF
    0020B 4F5F      SBCI	R21,0xFF
    0020C E088      LDI	R24,0x8
    0020D E090      LDI	R25,0
    0020E 1748      CP	R20,R24
    0020F 0759      CPC	R21,R25
    00210 F37C      BLT	0x0200
(0070)     }
(0071) 
(0072)     LCD_Comm(0x48);     // CGRAM 주소: 0b01 001000
    00211 E408      LDI	R16,0x48
    00212 940E 0274 CALL	_LCD_Comm
(0073)     for (int i = 0; i < 8; i++) {
    00214 2744      CLR	R20
    00215 2755      CLR	R21
    00216 C00D      RJMP	0x0224
(0074)         LCD_Data(q2_2[i]);
    00217 01CE      MOVW	R24,R28
    00218 9608      ADIW	R24,0x8
    00219 01FA      MOVW	R30,R20
    0021A 0FE8      ADD	R30,R24
    0021B 1FF9      ADC	R31,R25
    0021C 8100      LD	R16,Z
    0021D 940E 0253 CALL	_LCD_Data
(0075)         LCD_delay(1);
    0021F E001      LDI	R16,1
    00220 940E 0245 CALL	_LCD_delay
    00222 5F4F      SUBI	R20,0xFF
    00223 4F5F      SBCI	R21,0xFF
    00224 E088      LDI	R24,0x8
    00225 E090      LDI	R25,0
    00226 1748      CP	R20,R24
    00227 0759      CPC	R21,R25
    00228 F374      BLT	0x0217
(0076)     }
(0077) 
(0078)     LCD_Comm(0x50);     // CGRAM 주소: 0b01 010000
    00229 E500      LDI	R16,0x50
    0022A 940E 0274 CALL	_LCD_Comm
(0079)     for (int i = 0; i < 8; i++) {
    0022C 2744      CLR	R20
    0022D 2755      CLR	R21
    0022E C00D      RJMP	0x023C
(0080)         LCD_Data(q2_3[i]);
    0022F 01CE      MOVW	R24,R28
    00230 9640      ADIW	R24,0x10
    00231 01FA      MOVW	R30,R20
    00232 0FE8      ADD	R30,R24
    00233 1FF9      ADC	R31,R25
    00234 8100      LD	R16,Z
    00235 940E 0253 CALL	_LCD_Data
(0081)         LCD_delay(1);
    00237 E001      LDI	R16,1
    00238 940E 0245 CALL	_LCD_delay
    0023A 5F4F      SUBI	R20,0xFF
    0023B 4F5F      SBCI	R21,0xFF
    0023C E088      LDI	R24,0x8
    0023D E090      LDI	R25,0
    0023E 1748      CP	R20,R24
    0023F 0759      CPC	R21,R25
    00240 F374      BLT	0x022F
    00241 9668      ADIW	R28,0x18
    00242 9159      LD	R21,Y+
    00243 9149      LD	R20,Y+
    00244 9508      RET
(0082)     }
(0083) }
(0084) /* 3번 CGRAM data (생각중...)
(0085) void CGRAM_set_quiz3(void) {
(0086)     Byte q3_1[] = {}
(0087)     Byte q3_2[];
(0088)     Byte q3_3[];
(0089)     Byte q3_4[];
(0090) 
(0091)     LCD_Comm(0x40);
(0092)     for (int i = 0; i < 8; i++) {
(0093)         LCD_Data(q3_1[i]);
(0094)         LCD_delay(1);
(0095)     }
(0096) 
(0097)     LCD_Comm(0x48);
(0098)     for (int i = 0; i < 8; i++) {
(0099)         LCD_Data(q3_2[i]);
(0100)         LCD_delay(1);
(0101)     }
(0102) 
(0103)     LCD_Comm(0x50);
(0104)     for (int i = 0; i < 8; i++) {
(0105)         LCD_Data(q3_3[i]);
(0106)         LCD_delay(1);
(0107)     }
(0108) 
(0109)     LCD_Comm(0x58);
(0110)     for (int i = 0; i < 8; i++) {
(0111)         LCD_Data(q3_4[i]);
(0112)         LCD_delay(1);
(0113)     }
(0114) 
(0115) }*/
    00246 2EA0      MOV	R10,R16
FILE: C:\Users\user\Desktop\hidden-catch\lcd.c
(0001) #include "lcd.h"
(0002) 
(0003) void LCD_delay(Byte ms) { delay_ms(ms); }   // LCD time delay
    00247 2D0A      MOV	R16,R10
    00248 2711      CLR	R17
    00249 940E 0431 CALL	_delay_ms
    0024B 90A9      LD	R10,Y+
    0024C 9508      RET
(0004) 
(0005) void PortInit(void) {
(0006)     DDRA = 0xFF;    // PORTA to output mode
_PortInit:
    0024D EF8F      LDI	R24,0xFF
    0024E BB8A      OUT	0x1A,R24
(0007)     DDRG = 0x0F;    // PORTG 0~3 to output mode
    0024F E08F      LDI	R24,0xF
    00250 9380 0064 STS	0x64,R24
    00252 9508      RET
(0008) }
_LCD_Data:
  ch                   --> R10
    00253 92AA      ST	-Y,R10
    00254 2EA0      MOV	R10,R16
(0009) 
(0010) void LCD_Data(Byte ch) {
(0011)     LCD_CTRL |=  (1 << LCD_RS); // RS  = 1
    00255 9180 0065 LDS	R24,0x65
    00257 6084      ORI	R24,4
    00258 9380 0065 STS	0x65,R24
(0012)     LCD_CTRL &= ~(1 << LCD_RW); // R/W = 0 -> Enter data write cycle
    0025A 9180 0065 LDS	R24,0x65
    0025C 7F8D      ANDI	R24,0xFD
    0025D 9380 0065 STS	0x65,R24
(0013)     LCD_CTRL |=  (1 << LCD_EN); // enable LCD
    0025F 9180 0065 LDS	R24,0x65
    00261 6081      ORI	R24,1
    00262 9380 0065 STS	0x65,R24
(0014)     delay_us(50);
    00264 E302      LDI	R16,0x32
    00265 E010      LDI	R17,0
    00266 940E 0448 CALL	_delay_us
(0015) 
(0016)     LCD_WDATA = ch;             // Write DATA
    00268 BAAB      OUT	0x1B,R10
(0017)     delay_us(50);
    00269 E302      LDI	R16,0x32
    0026A E010      LDI	R17,0
    0026B 940E 0448 CALL	_delay_us
(0018) 
(0019)     LCD_CTRL &= ~(1 << LCD_EN); // disable LCD
    0026D 9180 0065 LDS	R24,0x65
    0026F 7F8E      ANDI	R24,0xFE
    00270 9380 0065 STS	0x65,R24
    00272 90A9      LD	R10,Y+
    00273 9508      RET
(0020) }   // Write Data to LCD Data Register (CGRAM, DDRAM)
_LCD_Comm:
  ch                   --> R10
    00274 92AA      ST	-Y,R10
    00275 2EA0      MOV	R10,R16
(0021) 
(0022) void LCD_Comm(Byte ch) {
(0023)     LCD_CTRL &= ~(1 << LCD_RS); // RS  = 0
    00276 9180 0065 LDS	R24,0x65
    00278 7F8B      ANDI	R24,0xFB
    00279 9380 0065 STS	0x65,R24
(0024)     LCD_CTRL &= ~(1 << LCD_RW); // R/W = 0 -> Enter instruction write cycle
    0027B 9180 0065 LDS	R24,0x65
    0027D 7F8D      ANDI	R24,0xFD
    0027E 9380 0065 STS	0x65,R24
(0025)     LCD_CTRL |=  (1 << LCD_EN); // enable LCD
    00280 9180 0065 LDS	R24,0x65
    00282 6081      ORI	R24,1
    00283 9380 0065 STS	0x65,R24
(0026)     delay_us(50);
    00285 E302      LDI	R16,0x32
    00286 E010      LDI	R17,0
    00287 940E 0448 CALL	_delay_us
(0027) 
(0028)     LCD_WINST = ch;             // Write INSTruction
    00289 BAAB      OUT	0x1B,R10
(0029)     delay_us(50);
    0028A E302      LDI	R16,0x32
    0028B E010      LDI	R17,0
    0028C 940E 0448 CALL	_delay_us
(0030) 
(0031)     LCD_CTRL &= ~(1 << LCD_EN); // disable LCD
    0028E 9180 0065 LDS	R24,0x65
    00290 7F8E      ANDI	R24,0xFE
    00291 9380 0065 STS	0x65,R24
    00293 90A9      LD	R10,Y+
    00294 9508      RET
(0032) }   // Write Instruction to LCD Instruction Register (CGRAM, DDRAM)
_LCD_Shift:
  p                    --> R20
    00295 934A      ST	-Y,R20
    00296 2F40      MOV	R20,R16
(0033) 
(0034) void LCD_Shift(char p) { // *
(0035)     if (p == RIGHT) {
    00297 3041      CPI	R20,1
    00298 F429      BNE	0x029E
(0036)         LCD_Comm(0x1C);         // command: 0b00011100
    00299 E10C      LDI	R16,0x1C
    0029A DFD9      RCALL	_LCD_Comm
(0037)         LCD_delay(1);
    0029B E001      LDI	R16,1
    0029C DFA8      RCALL	_LCD_delay
(0038)     }
    0029D C006      RJMP	0x02A4
(0039)     else if (p == LEFT) {
    0029E 2344      TST	R20
    0029F F421      BNE	0x02A4
(0040)         LCD_Comm(0x18);         // command: 0b00011000
    002A0 E108      LDI	R16,0x18
    002A1 DFD2      RCALL	_LCD_Comm
(0041)         LCD_delay(1);
    002A2 E001      LDI	R16,1
    002A3 DFA1      RCALL	_LCD_delay
    002A4 9149      LD	R20,Y+
    002A5 9508      RET
(0042)     }
(0043) }
_LCD_CHAR:
  c                    --> R10
    002A6 92AA      ST	-Y,R10
    002A7 2EA0      MOV	R10,R16
(0044) 
(0045) void LCD_CHAR(Byte c) {
(0046)     LCD_delay(1);
    002A8 E001      LDI	R16,1
    002A9 DF9B      RCALL	_LCD_delay
(0047)     LCD_Data(c);    // write char data C
    002AA 2D0A      MOV	R16,R10
    002AB DFA7      RCALL	_LCD_Data
    002AC 90A9      LD	R10,Y+
    002AD 9508      RET
(0048) }
_LCD_STR:
  str                  --> R20
    002AE 934A      ST	-Y,R20
    002AF 935A      ST	-Y,R21
    002B0 01A8      MOVW	R20,R16
(0049) 
(0050) void LCD_STR(Byte *str) {
    002B1 C005      RJMP	0x02B7
(0051)     while (*str != 0) {
(0052)         LCD_CHAR(*str); // write string data 'str'
    002B2 01FA      MOVW	R30,R20
    002B3 8100      LD	R16,Z
    002B4 DFF1      RCALL	_LCD_CHAR
(0053)         str++;
    002B5 5F4F      SUBI	R20,0xFF
    002B6 4F5F      SBCI	R21,0xFF
    002B7 01FA      MOVW	R30,R20
    002B8 8020      LD	R2,Z
    002B9 2022      TST	R2
    002BA F7B9      BNE	0x02B2
    002BB 9159      LD	R21,Y+
    002BC 9149      LD	R20,Y+
    002BD 9508      RET
(0054)     }
(0055) }
_LCD_pos:
  col                  --> R10
  row                  --> R12
    002BE 92AA      ST	-Y,R10
    002BF 92CA      ST	-Y,R12
    002C0 2EA2      MOV	R10,R18
    002C1 2EC0      MOV	R12,R16
(0056) 
(0057) void LCD_pos(unsigned char row, unsigned char col) {
(0058)     LCD_Comm(0x80 | (row * 0x40 + col));
    002C2 2D2C      MOV	R18,R12
    002C3 2733      CLR	R19
    002C4 E400      LDI	R16,0x40
    002C5 E010      LDI	R17,0
    002C6 940E 0554 CALL	empy16s
    002C8 0D0A      ADD	R16,R10
    002C9 6800      ORI	R16,0x80
    002CA DFA9      RCALL	_LCD_Comm
    002CB 90C9      LD	R12,Y+
    002CC 90A9      LD	R10,Y+
    002CD 9508      RET
(0059) }
(0060) 
(0061) void LCD_Clear(void) {
(0062)     LCD_Comm(0x01);
_LCD_Clear:
    002CE E001      LDI	R16,1
    002CF DFA4      RCALL	_LCD_Comm
(0063)     LCD_delay(2);
    002D0 E002      LDI	R16,2
    002D1 CF73      RJMP	_LCD_delay
(0064) }
(0065) 
(0066) void LCD_Init(void) {
(0067)     LCD_Comm(0x38); // DDRAM, 8 bit data 사용, lCD 2열로 사용
_LCD_Init:
    002D2 E308      LDI	R16,0x38
    002D3 DFA0      RCALL	_LCD_Comm
(0068)     LCD_delay(2);   // 2ms delay
    002D4 E002      LDI	R16,2
    002D5 DF6F      RCALL	_LCD_delay
(0069)     LCD_Comm(0x38);
    002D6 E308      LDI	R16,0x38
    002D7 DF9C      RCALL	_LCD_Comm
(0070)     LCD_delay(2);
    002D8 E002      LDI	R16,2
    002D9 DF6B      RCALL	_LCD_delay
(0071)     LCD_Comm(0x38);
    002DA E308      LDI	R16,0x38
    002DB DF98      RCALL	_LCD_Comm
(0072)     LCD_delay(2);
    002DC E002      LDI	R16,2
    002DD DF67      RCALL	_LCD_delay
(0073)     // 중요 초기 설정이라 3회 반복
(0074)     LCD_Comm(0x0C); // LCD 화면 ON, 커서 off, 문자 점멸 off (커서 on: 0x0E)
    002DE E00C      LDI	R16,0xC
    002DF DF94      RCALL	_LCD_Comm
(0075)     LCD_delay(2);
    002E0 E002      LDI	R16,2
    002E1 DF63      RCALL	_LCD_delay
(0076)     LCD_Comm(0x01); // Clear Display
    002E2 E001      LDI	R16,1
    002E3 DF90      RCALL	_LCD_Comm
(0077)     LCD_delay(30);
    002E4 E10E      LDI	R16,0x1E
    002E5 DF5F      RCALL	_LCD_delay
(0078)     LCD_Comm(0x06); // entry mode set (l->R 커서 이동, 화면 shift 없음)
    002E6 E006      LDI	R16,6
    002E7 DF8C      RCALL	_LCD_Comm
(0079)     LCD_delay(2);
    002E8 E002      LDI	R16,2
    002E9 CF5B      RJMP	_LCD_delay
(0080) }
(0081) 
(0082) void Cursor_Home(void) {
(0083)     LCD_Comm(0x02); // move LCD cursor to home
_Cursor_Home:
    002EA E002      LDI	R16,2
    002EB DF88      RCALL	_LCD_Comm
(0084)     LCD_delay(2);
    002EC E002      LDI	R16,2
    002ED CF57      RJMP	_LCD_delay
(0085) }
_Interrupt_init:
    002EE B789      IN	R24,0x39
    002EF 6081      ORI	R24,1
    002F0 BF89      OUT	0x39,R24
    002ED CF57      RJMP	_LCD_delay
FILE: C:\Users\user\Desktop\hidden-catch\main.c
(0001) #include <iom128v.h>
(0002) #include "my128.h"
(0003) #include "lcd.h"
(0004) #include "cgram.h"
(0005) #include "utils.h"
(0006) 
(0007) unsigned int score = 0; // 점수 저장
(0008) 
(0009) // flags: start / quiz 1~8 sequence 진행중이면 1, 아직 진행 전이거나 완료되었으면 0
(0010) int start_flag = 0;
(0011) int q1_flag = 0;
(0012) int q2_flag = 0;
(0013) 
(0014) // 버튼 0~3으로 커서 이동 인터럽트 작성
(0015) 
(0016) void Interrupt_init(void) {
(0017)     EIMSK |= 1 << INT0;          // INT0 버튼 인터럽트 허용
_Interrupt_init:
    002EE B789      IN	R24,0x39
    002EF 6081      ORI	R24,1
    002F0 BF89      OUT	0x39,R24
(0018)     EICRA |= 1 << ISC01 | 1 << ISC11 | 1 << ISC21 | 1 << ISC31;
    002F1 9180 006A LDS	R24,0x6A
    002F3 6A8A      ORI	R24,0xAA
    002F4 9380 006A STS	0x6A,R24
(0019)     // INT0~INT3 falling edge trigger 설정
(0020)     EICRB |= 1 << ISC41 | 1 << ISC51 | 1 << ISC61 | 1 << ISC71;
    002F6 B78A      IN	R24,0x3A
    002F7 6A8A      ORI	R24,0xAA
    002F8 BF8A      OUT	0x3A,R24
(0021)     // INT4~INT7 falling edge trigger 설정
(0022)     SREG |= 0x80;           // 전역 인터럽트 허가
    002F9 9478      BSET	7
    002FA 9508      RET
(0023) }
(0024) 
(0025) void LCD_game_start(void) {
(0026)     if (start_flag) {
    002FB 9020 0102 LDS	R2,_start_flag
    002FD 9030 0103 LDS	R3,_start_flag+1
    002FF 2022      TST	R2
    00300 F419      BNE	0x0304
    00301 2033      TST	R3
    00302 F409      BNE	0x0304
    00303 C044      RJMP	0x0348
(0027)         Cursor_Home();
    00304 940E 02EA CALL	_Cursor_Home
(0028)         LCD_STR("Starting in...");
    00306 E307      LDI	R16,0x37
    00307 E011      LDI	R17,1
    00308 940E 02AE CALL	_LCD_STR
(0029)         LCD_pos(0,15);
    0030A E02F      LDI	R18,0xF
    0030B 2700      CLR	R16
    0030C 940E 02BE CALL	_LCD_pos
(0030)         LCD_STR("3");
    0030E E305      LDI	R16,0x35
    0030F E011      LDI	R17,1
    00310 940E 02AE CALL	_LCD_STR
(0031)         delay_ms(1000);
    00312 EE08      LDI	R16,0xE8
    00313 E013      LDI	R17,3
    00314 940E 0431 CALL	_delay_ms
(0032) 
(0033)         LCD_pos(0,15);
    00316 E02F      LDI	R18,0xF
    00317 2700      CLR	R16
    00318 940E 02BE CALL	_LCD_pos
(0034)         LCD_STR("2");
    0031A E303      LDI	R16,0x33
    0031B E011      LDI	R17,1
    0031C 940E 02AE CALL	_LCD_STR
(0035)         delay_ms(1000);
    0031E EE08      LDI	R16,0xE8
    0031F E013      LDI	R17,3
    00320 940E 0431 CALL	_delay_ms
(0036) 
(0037)         LCD_pos(0,15);
    00322 E02F      LDI	R18,0xF
    00323 2700      CLR	R16
    00324 940E 02BE CALL	_LCD_pos
(0038)         LCD_STR("1");
    00326 E301      LDI	R16,0x31
    00327 E011      LDI	R17,1
    00328 940E 02AE CALL	_LCD_STR
(0039)         delay_ms(1000);
    0032A EE08      LDI	R16,0xE8
    0032B E013      LDI	R17,3
    0032C 940E 0431 CALL	_delay_ms
(0040) 
(0041)         LCD_Clear();
    0032E 940E 02CE CALL	_LCD_Clear
(0042)         Cursor_Home();
    00330 940E 02EA CALL	_Cursor_Home
(0043)         LCD_STR("GO!!!");
    00332 E20B      LDI	R16,0x2B
    00333 E011      LDI	R17,1
    00334 940E 02AE CALL	_LCD_STR
(0044)         delay_ms(800);
    00336 E200      LDI	R16,0x20
    00337 E013      LDI	R17,3
    00338 940E 0431 CALL	_delay_ms
(0045) 
(0046)         LCD_Clear();
    0033A 940E 02CE CALL	_LCD_Clear
(0047)         start_flag = 0; // start sequence 종료
    0033C 2422      CLR	R2
    0033D 2433      CLR	R3
    0033E 9230 0103 STS	_start_flag+1,R3
    00340 9220 0102 STS	_start_flag,R2
(0048)         q1_flag = 1;    // quiz1 sequence 시작
    00342 E081      LDI	R24,1
    00343 E090      LDI	R25,0
    00344 9390 0105 STS	_q1_flag+1,R25
    00346 9380 0104 STS	_q1_flag,R24
    00348 9508      RET
(0049)     }
(0050) }
    00349 940E 056F CALL	push_xgsetF0FC
    0034B 9721      SBIW	R28,1
(0051) 
(0052) void Quiz_1(void) {     // 꽉 찬 CLCD의 문자들 중 다른 영어 문자 1개 찾기
(0053)     Cursor_Home();
    0034C 940E 02EA CALL	_Cursor_Home
(0054) 
(0055)     LCD_STR("AAAAAAAAAAAAAAAA");
    0034E E10A      LDI	R16,0x1A
    0034F E011      LDI	R17,1
    00350 940E 02AE CALL	_LCD_STR
(0056)     LCD_pos(1,0);
    00352 2722      CLR	R18
    00353 E001      LDI	R16,1
    00354 940E 02BE CALL	_LCD_pos
(0057)     LCD_STR("AAAAAAAAAAAAAAAA");
    00356 E10A      LDI	R16,0x1A
    00357 E011      LDI	R17,1
    00358 940E 02AE CALL	_LCD_STR
(0058)     // A 문자로 32칸 다 채움
(0059) 
(0060)     Byte answer_row = get_random(2);    // 0, 1행 중 랜덤 하나 선택
    0035A E002      LDI	R16,2
    0035B E010      LDI	R17,0
    0035C 940E 04CF CALL	_get_random
    0035E 8308      ST	Y,R16
(0061)     Byte answer_col = get_random(16);   // 0~15열 중 랜덤 하나 선택
    0035F E100      LDI	R16,0x10
    00360 E010      LDI	R17,0
    00361 940E 04CF CALL	_get_random
    00363 2EC0      MOV	R12,R16
(0062) 
(0063)     LCD_pos(answer_row, answer_col);
    00364 2D2C      MOV	R18,R12
    00365 8108      LD	R16,Y
    00366 940E 02BE CALL	_LCD_pos
(0064)     LCD_STR("B");               // 랜덤한 행,열에 B 문자 출력
    00368 E108      LDI	R16,0x18
    00369 E011      LDI	R17,1
    0036A 940E 02AE CALL	_LCD_STR
(0065) 
(0066)     LCD_Comm(0x0E);             // lCD 커서 on (1번 문제 진행에 필요)
    0036C E00E      LDI	R16,0xE
    0036D 940E 0274 CALL	_LCD_Comm
(0067)     Cursor_Home();
    0036F 940E 02EA CALL	_Cursor_Home
(0068) 
(0069)     Byte cursor_row = 0, cursor_col = 0;
    00371 2744      CLR	R20
    00372 2766      CLR	R22
    00373 C062      RJMP	0x03D6
(0070)     while (q1_flag == 1) {
(0071)         Byte D = PIND & 0xFF;
    00374 B380      IN	R24,0x10
    00375 7F8F      ANDI	R24,0xFF
    00376 2EE8      MOV	R14,R24
(0072)         switch (D) {
    00377 2EA8      MOV	R10,R24
    00378 3B8F      CPI	R24,0xBF
    00379 F0C9      BEQ	0x0393
    0037A EB8F      LDI	R24,0xBF
    0037B 158E      CP	R24,R14
    0037C F020      BCS	0x0381
    0037D 2D8A      MOV	R24,R10
    0037E 378F      CPI	R24,0x7F
    0037F F0C1      BEQ	0x0398
    00380 C01A      RJMP	0x039B
    00381 2D8A      MOV	R24,R10
    00382 3D8F      CPI	R24,0xDF
    00383 F059      BEQ	0x038F
    00384 3D8F      CPI	R24,0xDF
    00385 F0A8      BCS	0x039B
    00386 2D8A      MOV	R24,R10
    00387 3E8F      CPI	R24,0xEF
    00388 F009      BEQ	0x038A
    00389 C011      RJMP	0x039B
(0073)             case 0b11101111: if (cursor_row > 0) cursor_row--; break;   // PD4, move cursor up
    0038A 2422      CLR	R2
    0038B 1624      CP	R2,R20
    0038C F470      BCC	0x039B
    0038D 954A      DEC	R20
    0038E C00C      RJMP	0x039B
(0074)             case 0b11011111: if (cursor_row < 1) cursor_row++; break;   // PD5, move cursor down
    0038F 3041      CPI	R20,1
    00390 F450      BCC	0x039B
    00391 9543      INC	R20
    00392 C008      RJMP	0x039B
(0075)             case 0b10111111: if (cursor_col > 0) cursor_col--; break;   // PD6, move cursor left
    00393 2422      CLR	R2
    00394 1626      CP	R2,R22
    00395 F428      BCC	0x039B
    00396 956A      DEC	R22
    00397 C003      RJMP	0x039B
(0076)             case 0b01111111: if (cursor_col < 15) cursor_col++; break;  // PD7, move cursor right
    00398 306F      CPI	R22,0xF
    00399 F408      BCC	0x039B
    0039A 9563      INC	R22
(0077)         }
(0078) 
(0079)         LCD_pos(cursor_row, cursor_col);
    0039B 2F26      MOV	R18,R22
    0039C 2F04      MOV	R16,R20
    0039D 940E 02BE CALL	_LCD_pos
(0080) 
(0081)         if (D == 0b11111101) {  // 사용자가 커서 이동 완료 후 정답 선택 버튼 (PD1) 눌렀을 때
    0039F 2D8E      MOV	R24,R14
    003A0 3F8D      CPI	R24,0xFD
    003A1 F581      BNE	0x03D2
(0082)             if (cursor_row == answer_row && cursor_col == answer_col) {
    003A2 8008      LD	R0,Y
    003A3 1540      CP	R20,R0
    003A4 F4F1      BNE	0x03C3
    003A5 156C      CP	R22,R12
    003A6 F4E1      BNE	0x03C3
(0083)                 // 만약 정답 위치와 커서 위치 일치 시 정답
(0084)                 q1_flag = 0; score++;   // quiz1 flag 내림 (q1 sequence 종료), score 증가
    003A7 2422      CLR	R2
    003A8 2433      CLR	R3
    003A9 9230 0105 STS	_q1_flag+1,R3
    003AB 9220 0104 STS	_q1_flag,R2
    003AD 9180 0100 LDS	R24,_score
    003AF 9190 0101 LDS	R25,_score+1
    003B1 9601      ADIW	R24,1
    003B2 9390 0101 STS	_score+1,R25
    003B4 9380 0100 STS	_score,R24
(0085)                 LCD_Clear(); Cursor_Home(); LCD_STR("Correct!");    // 정답 메세지 출력
    003B6 940E 02CE CALL	_LCD_Clear
    003B8 940E 02EA CALL	_Cursor_Home
    003BA E00F      LDI	R16,0xF
    003BB E011      LDI	R17,1
    003BC 940E 02AE CALL	_LCD_STR
(0086)                 LED_correct(); LCD_Clear(); // LED 점등, 이후 LCD clear, 커서 제거
    003BE 940E 045F CALL	_LED_correct
    003C0 940E 02CE CALL	_LCD_Clear
(0087)                 break;
    003C2 C01C      RJMP	0x03DF
(0088)             }
(0089)             else {
(0090)             // 아니면 오답 처리 후 새로운 문제 출제
(0091)                 LCD_Clear(); Cursor_Home(); LCD_STR("Wrong!");  // 오답 메시지 출력
    003C3 940E 02CE CALL	_LCD_Clear
    003C5 940E 02EA CALL	_Cursor_Home
    003C7 E008      LDI	R16,0x8
    003C8 E011      LDI	R17,1
    003C9 940E 02AE CALL	_LCD_STR
(0092)                 delay_ms(1000); LCD_Clear(); Quiz_1();  // LCD clear 후 새 문제 출제
    003CB EE08      LDI	R16,0xE8
    003CC E013      LDI	R17,3
    003CD 940E 0431 CALL	_delay_ms
    003CF 940E 02CE CALL	_LCD_Clear
    003D1 DF77      RCALL	_Quiz_1
(0093)             }
(0094)         }
(0095) 
(0096)         delay_ms(100); // 버튼 입력 간 딜레이 조절 가능
    003D2 E604      LDI	R16,0x64
    003D3 E010      LDI	R17,0
    003D4 940E 0431 CALL	_delay_ms
    003D6 9180 0104 LDS	R24,_q1_flag
    003D8 9190 0105 LDS	R25,_q1_flag+1
    003DA 3081      CPI	R24,1
    003DB E0E0      LDI	R30,0
    003DC 079E      CPC	R25,R30
    003DD F409      BNE	0x03DF
    003DE CF95      RJMP	0x0374
(0097)     }
(0098)     // 문제 출제 종료 (A,B) 더이상 출력하지 않게 설정
(0099) 
(0100)     LCD_Comm(0x0C);     // LCD 커서 off
    003DF E00C      LDI	R16,0xC
    003E0 940E 0274 CALL	_LCD_Comm
(0101)     Cursor_Home();      // lCD 커서 홈으로 이동
    003E2 940E 02EA CALL	_Cursor_Home
(0102) }
    003E4 9621      ADIW	R28,1
    003E5 940C 0564 JMP	pop_xgsetF0FC
    003E7 9508      RET
(0103) 
(0104) void Quiz_2(void) {
    003E8 940C 02EA JMP	_Cursor_Home
(0105)     // CGROM- '식': 0x00, '사': 0x01, '샤': 0x02
(0106) 
(0107)     Cursor_Home();
(0108) }
(0109) 
(0110) void main(void) {
(0111)     DDRB = 0xFF;        // PORTB 출력 모드 (LED)
    003EA EF8F      LDI	R24,0xFF
    003EB BB87      OUT	0x17,R24
(0112)     PORTB = 0xFF;       // LED 전체 off
    003EC BB88      OUT	0x18,R24
(0113) 
(0114)     DDRD = 0xFF;        // PORTD 출력 모드 (버튼)
    003ED BB81      OUT	0x11,R24
(0115)     PORTD = 0xFF;       // PORTD 내부 풀업 저항 사용하기 위해 Set
    003EE BB82      OUT	0x12,R24
(0116)     SFIOR |= 0x04;      // PUD bit 1로 설정
    003EF B580      IN	R24,0x20
    003F0 6084      ORI	R24,4
    003F1 BD80      OUT	0x20,R24
(0117) 
(0118)     Interrupt_init();
    003F2 DEFB      RCALL	_Interrupt_init
(0119)     PortInit();
    003F3 940E 024D CALL	_PortInit
(0120)     LCD_Init();
    003F5 940E 02D2 CALL	_LCD_Init
(0121) 
(0122)     CGRAM_set_menu();
    003F7 940E 00D7 CALL	_CGRAM_set_menu
(0123)     Cursor_Home();
    003F9 940E 02EA CALL	_Cursor_Home
(0124)     LCD_menu();
    003FB 940E 01C6 CALL	_LCD_menu
(0125)     delay_ms(10);
    003FD E00A      LDI	R16,0xA
    003FE E010      LDI	R17,0
    003FF 940E 0431 CALL	_delay_ms
    00401 C02D      RJMP	0x042F
(0126) 
(0127)     while (1) {
(0128)         if ((PIND & 0xFF) == 0b01111111) {  // PD7 눌러서 퀴즈 시작
    00402 B380      IN	R24,0x10
    00403 7F8F      ANDI	R24,0xFF
    00404 378F      CPI	R24,0x7F
    00405 F439      BNE	0x040D
(0129)             // 테스트할 때에는 rxdata == 'A'로 변경
(0130)             start_flag = 1;
    00406 E081      LDI	R24,1
    00407 E090      LDI	R25,0
    00408 9390 0103 STS	_start_flag+1,R25
    0040A 9380 0102 STS	_start_flag,R24
(0131)             LCD_game_start();
    0040C DEEE      RCALL	_LCD_game_start
(0132)         }
(0133)         if (start_flag == 0 && q1_flag == 1)
    0040D 9020 0102 LDS	R2,_start_flag
    0040F 9030 0103 LDS	R3,_start_flag+1
    00411 2022      TST	R2
    00412 F459      BNE	0x041E
    00413 2033      TST	R3
    00414 F449      BNE	0x041E
    00415 9180 0104 LDS	R24,_q1_flag
    00417 9190 0105 LDS	R25,_q1_flag+1
    00419 3081      CPI	R24,1
    0041A E0E0      LDI	R30,0
    0041B 079E      CPC	R25,R30
    0041C F409      BNE	0x041E
(0134)             Quiz_1();
    0041D DF2B      RCALL	_Quiz_1
(0135)         if (start_flag == 0 && q2_flag == 1)
    0041E 9020 0102 LDS	R2,_start_flag
    00420 9030 0103 LDS	R3,_start_flag+1
    00422 2022      TST	R2
    00423 F459      BNE	0x042F
    00424 2033      TST	R3
    00425 F449      BNE	0x042F
    00426 9180 0106 LDS	R24,_q2_flag
    00428 9190 0107 LDS	R25,_q2_flag+1
    0042A 3081      CPI	R24,1
    0042B E0E0      LDI	R30,0
    0042C 079E      CPC	R25,R30
    0042D F409      BNE	0x042F
(0136)             Quiz_2();
    0042E DFB9      RCALL	_Quiz_2
    0042F CFD2      RJMP	0x0402
    00430 9508      RET
(0137)     }
(0138) 
(0139) }
    00431 940E 057A CALL	push_xgsetF000
    00432 057A      CPC	R23,R10
FILE: C:\Users\user\Desktop\hidden-catch\my128.c
(0001) #include "my128.h"
(0002) 
(0003) void delay_ms(unsigned int m) {
(0004)     unsigned int i, j;
(0005)     
(0006)     for (i = 0; i < m; i++)
    00433 2744      CLR	R20
    00434 2755      CLR	R21
    00435 C00C      RJMP	0x0442
(0007)         for (j = 0; j < 2130; j++)
    00436 2766      CLR	R22
    00437 2777      CLR	R23
    00438 C002      RJMP	0x043B
    00439 5F6F      SUBI	R22,0xFF
    0043A 4F7F      SBCI	R23,0xFF
    0043B E582      LDI	R24,0x52
    0043C E098      LDI	R25,0x8
    0043D 1768      CP	R22,R24
    0043E 0779      CPC	R23,R25
    0043F F3C8      BCS	0x0439
    00440 5F4F      SUBI	R20,0xFF
    00441 4F5F      SBCI	R21,0xFF
    00442 1740      CP	R20,R16
    00443 0751      CPC	R21,R17
    00444 F388      BCS	0x0436
    00445 940C 057F JMP	pop_xgsetF000
    00447 9508      RET
(0008)             ;
(0009) }   // delay_ms definition
_delay_us:
  i                    --> R20
  j                    --> R22
  m                    --> R16
    00448 940E 057A CALL	push_xgsetF000
(0010) 
(0011) void delay_us(unsigned int m) {
(0012)     unsigned int i, j;
(0013) 
(0014)     for (i = 0; i < m; i++)
    0044A 2744      CLR	R20
    0044B 2755      CLR	R21
    0044C C00C      RJMP	0x0459
(0015)         for (j = 0; j < 2; j++)
    0044D 2766      CLR	R22
    0044E 2777      CLR	R23
    0044F C002      RJMP	0x0452
    00450 5F6F      SUBI	R22,0xFF
    00451 4F7F      SBCI	R23,0xFF
    00452 E082      LDI	R24,2
    00453 E090      LDI	R25,0
    00454 1768      CP	R22,R24
    00455 0779      CPC	R23,R25
    00456 F3C8      BCS	0x0450
    00457 5F4F      SUBI	R20,0xFF
    00458 4F5F      SBCI	R21,0xFF
    00459 1740      CP	R20,R16
    0045A 0751      CPC	R21,R17
    0045B F388      BCS	0x044D
    0045C 940C 057F JMP	pop_xgsetF000
    0045E 9508      RET
(0016)             ;
(0017) }   // delay_us definition
_LED_correct:
    0045F 2422      CLR	R2
    00460 BA28      OUT	0x18,R2
    0045A 0751      CPC	R21,R17
    0045B F388      BCS	0x044D
    0045C 940C 057F JMP	pop_xgsetF000
    0045E 9508      RET
FILE: C:\Users\user\Desktop\hidden-catch\utils.c
(0001) #include "utils.h"
(0002) 
(0003) void LED_correct(void) {  // 정답 시 LED 전체 점등 함수
(0004)     PORTB = 0x00; delay_ms(250);
_LED_correct:
    0045F 2422      CLR	R2
    00460 BA28      OUT	0x18,R2
    00461 EF0A      LDI	R16,0xFA
    00462 E010      LDI	R17,0
    00463 940E 0431 CALL	_delay_ms
(0005)     PORTB = 0xFF; delay_ms(250);
    00465 EF8F      LDI	R24,0xFF
    00466 BB88      OUT	0x18,R24
    00467 EF0A      LDI	R16,0xFA
    00468 E010      LDI	R17,0
    00469 940E 0431 CALL	_delay_ms
(0006)     PORTB = 0x00; delay_ms(250);
    0046B 2422      CLR	R2
    0046C BA28      OUT	0x18,R2
    0046D EF0A      LDI	R16,0xFA
    0046E E010      LDI	R17,0
    0046F 940E 0431 CALL	_delay_ms
(0007)     PORTB = 0xFF; delay_ms(250);
    00471 EF8F      LDI	R24,0xFF
    00472 BB88      OUT	0x18,R24
    00473 EF0A      LDI	R16,0xFA
    00474 E010      LDI	R17,0
    00475 940C 0431 JMP	_delay_ms
(0008) }
    00477 922A      ST	-Y,R2
    00478 B62F      IN	R2,0x3F
    00479 922A      ST	-Y,R2
(0009) 
(0010) Byte txdata = 0;    // 게임 종료 시 'B' 전송
(0011) Byte rxdata = 0;    // 'A' 수신 시 게임 시작
(0012) 
(0013) #pragma interrupt_handler usart0_transmit: iv_USART0_DRE
(0014) void usart0_transmit(void) { UDR0 = txdata; }
    0047A 9020 0146 LDS	R2,_txdata
    0047C B82C      OUT	0x0C,R2
    0047D 9029      LD	R2,Y+
    0047E BE2F      OUT	0x3F,R2
    0047F 9029      LD	R2,Y+
    00480 9518      RETI
    00481 922A      ST	-Y,R2
    00482 B62F      IN	R2,0x3F
    00483 922A      ST	-Y,R2
(0015) 
(0016) #pragma interrupt_handler usart0_receive: iv_USART0_RXC
(0017) void usart0_receive(void) { rxdata = UDR0; }
    00484 B02C      IN	R2,0x0C
    00485 9220 0147 STS	_rxdata,R2
    00487 9029      LD	R2,Y+
    00488 BE2F      OUT	0x3F,R2
    00489 9029      LD	R2,Y+
    0048A 9518      RETI
(0018) 
(0019) void Init_USART0(void) {
(0020)     UCSR0A &= ~(1 << U2X0); // 1배속 통신
    0048B 9859      CBI	0x0B,1
(0021) 
(0022)     UCSR0B = (1 << RXCIE0) | (1 << UDRIE0) | (1 << RXEN0) | (1 << TXEN0);
    0048C EB88      LDI	R24,0xB8
    0048D B98A      OUT	0x0A,R24
(0023)     // 송/수신 및 송/수신 인터럽트 허가
(0024)     UCSR0C = (1 << UPM01) | (1 << UCSZ01) | (1 << UCSZ00);
    0048E E286      LDI	R24,0x26
    0048F 9380 0095 STS	0x95,R24
(0025)     // 비동기식 통신, 짝수 패리티, 1bit stop bit, 8bit data
(0026) 
(0027)     UBRR0H = 0x00;
    00491 2422      CLR	R2
    00492 9220 0090 STS	0x90,R2
(0028)     UBRR0L = 0x67; // baud rate 9,600bps
    00494 E687      LDI	R24,0x67
    00495 B989      OUT	0x09,R24
(0029) 
(0030)     SREG |= 0x80;  // allow all interrupts
    00496 9478      BSET	7
    00497 9508      RET
(0031) }
(0032) 
(0033) void Init_Timer2(void) {
(0034)     TCCR2 = (1 << WGM21) | (1 << CS22) | (1 << CS21);   // CTC 모드, 분주비 256
    00498 E08E      LDI	R24,0xE
    00499 BD85      OUT	0x25,R24
(0035)     OCR2 = 250;
    0049A EF8A      LDI	R24,0xFA
    0049B BD83      OUT	0x23,R24
(0036)     TIMSK |= (1 << OCIE2);
    0049C B787      IN	R24,0x37
    0049D 6880      ORI	R24,0x80
    0049E BF87      OUT	0x37,R24
(0037)     TCNT2 = 0;
    0049F 2422      CLR	R2
    004A0 BC24      OUT	0x24,R2
    004A1 9508      RET
(0038) }
    004A2 922A      ST	-Y,R2
    004A3 923A      ST	-Y,R3
    004A4 924A      ST	-Y,R4
    004A5 925A      ST	-Y,R5
    004A6 938A      ST	-Y,R24
    004A7 939A      ST	-Y,R25
    004A8 93AA      ST	-Y,R26
    004A9 93BA      ST	-Y,R27
    004AA B62F      IN	R2,0x3F
    004AB 922A      ST	-Y,R2
(0039) 
(0040) #pragma interrupt_handler timer2_comp_isr: iv_TIM2_COMP
(0041) unsigned long long random_seed = 0;     // random seed (8 bytes)
(0042) 
(0043) void timer2_comp_isr(void) { random_seed ++; } // random_seed++ every 4ms
    004AC E081      LDI	R24,1
    004AD E090      LDI	R25,0
    004AE E0A0      LDI	R26,0
    004AF E0B0      LDI	R27,0
    004B0 9040 014A LDS	R4,_random_seed+2
    004B2 9050 014B LDS	R5,_random_seed+3
    004B4 9020 0148 LDS	R2,_random_seed
    004B6 9030 0149 LDS	R3,_random_seed+1
    004B8 0E28      ADD	R2,R24
    004B9 1E39      ADC	R3,R25
    004BA 1E4A      ADC	R4,R26
    004BB 1E5B      ADC	R5,R27
    004BC 9230 0149 STS	_random_seed+1,R3
    004BE 9220 0148 STS	_random_seed,R2
    004C0 9250 014B STS	_random_seed+3,R5
    004C2 9240 014A STS	_random_seed+2,R4
    004C4 9029      LD	R2,Y+
    004C5 BE2F      OUT	0x3F,R2
    004C6 91B9      LD	R27,Y+
    004C7 91A9      LD	R26,Y+
    004C8 9199      LD	R25,Y+
    004C9 9189      LD	R24,Y+
    004CA 9059      LD	R5,Y+
    004CB 9049      LD	R4,Y+
    004CC 9039      LD	R3,Y+
    004CD 9029      LD	R2,Y+
    004CE 9518      RETI
    004CF 92AA      ST	-Y,R10
    004D0 92BA      ST	-Y,R11
    004D1 0158      MOVW	R10,R16
(0044) 
(0045) int get_random(int max) { return random_seed % max; }
    004D2 0115      MOVW	R2,R10
    004D3 2444      CLR	R4
    004D4 FC37      SBRC	R3,7
    004D5 9440      COM	R4
    004D6 2455      CLR	R5
    004D7 FC47      SBRC	R4,7
    004D8 9450      COM	R5
    004D9 9120 014A LDS	R18,_random_seed+2
    004DB 9130 014B LDS	R19,_random_seed+3
    004DD 9100 0148 LDS	R16,_random_seed
    004DF 9110 0149 LDS	R17,_random_seed+1
    004E1 925A      ST	-Y,R5
    004E2 924A      ST	-Y,R4
    004E3 923A      ST	-Y,R3
    004E4 922A      ST	-Y,R2
    004E5 940E 04EC CALL	mod32u
    004E7 90B9      LD	R11,Y+
    004E8 90A9      LD	R10,Y+
    004E9 9508      RET
    004EA 94E8      BCLR	6
    004EB C001      RJMP	0x04ED
